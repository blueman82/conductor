# Integration Task Template
# For wiring multiple components together
# Updated: v2.3.0 - Added data flow, dependency verification, anti-patterns

- task_number: N
  type: integration  # REQUIRED marker
  name: "Wire Component A to Component B"
  agent: "fullstack-developer"  # Or appropriate integrator
  worktree_group: "chain-N"
  files:
    - "component/a/file.ext"
    - "component/b/file.ext"
    - "integration/point.ext"
  depends_on: [1, 2, 3, ...]  # All components being wired
  estimated_time: "45m"

  # ─────────────────────────────────────────────────────────────
  # DATA FLOW DOCUMENTATION (Critical for integration tasks)
  # ─────────────────────────────────────────────────────────────
  # Integration tasks MUST document all upstream dependencies
  # to ensure correct depends_on declaration.
  calls:
    - function: "FunctionFromTaskX"
      from_task: X
      package: "path/to/component/a"
      usage: "Called to get data for integration"
    - function: "FunctionFromTaskY"
      from_task: Y
      package: "path/to/component/b"
      usage: "Called to process integrated data"
    - type: "TypeFromTaskZ"
      from_task: Z
      package: "path/to/component/c"
      usage: "Data structure passed between components"
  # ─────────────────────────────────────────────────────────────

  # Component-level validation
  success_criteria:
    # Functional criteria
    - "Component A interface correct"
    - "Component B interface correct"
    - "Integration code compiles"

    # Data integration criteria (REQUIRED for integration tasks)
    - "Calls ComponentA.Function() from Task X with real data"
    - "Calls ComponentB.Function() from Task Y correctly"
    - "Uses TypeZ from Task Z for data transfer"

    # Anti-pattern criteria (AUTO-APPEND to ALL tasks)
    - "No TODO comments in production code paths"
    - "No placeholder empty structs (e.g., Type{})"
    - "No unused variables (_ = x pattern)"
    - "All imports from dependency tasks resolve"

  # Cross-component validation (REQUIRED for integration tasks)
  integration_criteria:
    - "Component A calls Component B correctly"
    - "Data flows end-to-end without modification loss"
    - "Error propagation works across component boundaries"
    - "Resource lifecycle managed (acquire/release)"
    - "Sequencing constraints met (A before B)"

  test_commands:
    - "integration test command"
    - "go test ./internal/integration/ -v"
    - "npm run test:integration"

  # ─────────────────────────────────────────────────────────────
  # DESCRIPTION WITH COMPREHENSIVE DEPENDENCY VERIFICATION
  # ─────────────────────────────────────────────────────────────
  description: |
    # Task N: Wire Component A to Component B

    ## PHASE 0: DEPENDENCY VERIFICATION (EXECUTE FIRST)

    **You MUST verify ALL dependencies exist before implementing:**

    ```bash
    # Verify Task X complete (Component A function exists)
    grep -q "func FunctionFromTaskX" path/to/component/a/file.ext && \
      echo "✓ Task X: FunctionFromTaskX ready" || \
      echo "❌ STOP: Task X incomplete"

    # Verify Task Y complete (Component B function exists)
    grep -q "func FunctionFromTaskY" path/to/component/b/file.ext && \
      echo "✓ Task Y: FunctionFromTaskY ready" || \
      echo "❌ STOP: Task Y incomplete"

    # Verify Task Z complete (Type exists)
    grep -q "type TypeFromTaskZ struct" path/to/component/c/file.ext && \
      echo "✓ Task Z: TypeFromTaskZ ready" || \
      echo "❌ STOP: Task Z incomplete"

    # Build check (verifies all imports resolve)
    go build ./path/to/... && echo "✓ All dependencies compile" || \
      echo "❌ STOP: Dependency compilation failed"
    ```

    **If ANY check fails:** Report "Dependency Task X incomplete" and STOP.
    Do NOT proceed with placeholder implementations.

    ---

    ## IMPLEMENTATION REQUIREMENTS

    **You MUST call these functions (from upstream tasks):**
    - `componenta.FunctionFromTaskX()` - from Task X
    - `componentb.FunctionFromTaskY()` - from Task Y

    **You MUST use these types:**
    - `TypeFromTaskZ` - from Task Z

    **PROHIBITED:**
    - ❌ TODO comments in production code
    - ❌ Placeholder empty structs: `data := &TypeFromTaskZ{}`
    - ❌ Unused variables: `_ = result`
    - ❌ Mocking upstream functions instead of calling them
    - ❌ Hardcoded test data instead of real function calls

    ---

    ## TASK DESCRIPTION

    Wire [Component A] to [Component B].

    Takes completed components and connects them,
    ensuring proper integration points.

    ## Dependency Context

    Dependencies (conductor auto-enhances with file details):
    - Task X: Component A implementation
    - Task Y: Component B implementation
    - Task Z: Shared data types

    ## Integration Steps
    1. Read Component A interfaces (verify exports)
    2. Read Component B interfaces (verify inputs)
    3. Import packages/modules
    4. Wire components together
    5. Add integration tests
    6. Verify end-to-end flow

  test_first:
    test_file: "path/to/integration_test.ext"

    structure:
      - "integration test suite"
      - "test: components communicate"
      - "test: data flows correctly"
      - "test: error handling end-to-end"

    mocks:
      - "external dependencies only (NOT upstream tasks)"

    fixtures:
      - "integration test data"

    assertions:
      - "end-to-end outcome verified"

  implementation:
    approach: |
      Integration approach:
      1. Import Component A and B
      2. Wire dependencies
      3. Ensure correct sequencing
      4. Handle errors across boundaries

    key_points:
      - point: "Component A exports X"
        reference: "component/a/file.ext:line"
      - point: "Component B expects Y"
        reference: "component/b/file.ext:line"
      - point: "Integration pattern"
        reference: "similar/integration.ext"

    integration:
      imports:
        - "import ComponentA from path"
        - "import ComponentB from path"
      services_to_inject:
        - "ComponentA instance"
        - "ComponentB instance"
      sequencing:
        - "Initialize A before B"
        - "Wire A.output to B.input"
      error_handling:
        - "Propagate errors from A to B"
        - "Wrap with integration context"

  verification:
    automated_tests:
      command: "integration test command"
      expected_output: "Integration tests pass"

    success_criteria:
      - "Component-level checks pass"

    integration_verification:
      - "Integration criteria all verified"
      - "End-to-end flow tested"

    # Anti-pattern verification
    anti_pattern_checks:
      - command: "grep -n 'TODO' path/to/integration/file.ext || true"
        expect: "no matches in production paths"
      - command: "grep -n '_ =' path/to/integration/file.ext || true"
        expect: "no unused variable assignments"
      - command: "grep -n 'Type{}' path/to/integration/file.ext || true"
        expect: "no empty placeholder structs"

  code_quality:
    # Language-specific pipeline
    go:
      full_quality_pipeline:
        command: |
          gofmt -w . && \
          go vet ./... && \
          go test ./... && \
          go test ./internal/integration/ -v
        description: "Quality pipeline with integration tests"
        exit_on_failure: true

    typescript:
      full_quality_pipeline:
        command: |
          npx prettier --write . && \
          npx tsc --noEmit && \
          npm test && \
          npm run test:integration
        description: "Quality pipeline with integration tests"
        exit_on_failure: true

    python:
      full_quality_pipeline:
        command: |
          python -m black . && \
          python -m mypy src/ && \
          python -m pytest && \
          python -m pytest tests/integration/ -v
        description: "Quality pipeline with integration tests"
        exit_on_failure: true

  commit:
    type: "feat"
    message: "integrate Component A with Component B"
    body: "Wires components for end-to-end functionality"
    files:
      - "component/a/file.ext"
      - "component/b/file.ext"
      - "integration/point.ext"
      - "integration_test.ext"
