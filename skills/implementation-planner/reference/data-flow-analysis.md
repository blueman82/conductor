# Data Flow Analysis for Dependency Resolution

**CRITICAL**: This phase prevents the most common planning failure - missing data dependencies.

## The Problem

Feature chain thinking produces WRONG dependencies:

```
WRONG:
  Task 16 (Export CLI) → "CLI chain" → depends_on: [13] (observe root)

  Result: Task 16 executes in Wave 3, but ExtractMetrics()
          doesn't exist until Task 4 completes in Wave 4.
  Outcome: RED - compilation error, placeholder code
```

Data flow thinking produces CORRECT dependencies:

```
RIGHT:
  Task 16 calls ExtractMetrics() → Who creates it? → Task 4
  Task 16 calls LoadSession() → Who creates it? → Task 5
  Task 16 registers as subcommand → Task 13 (observe root)

  depends_on: [4, 5, 13, 15]

  Result: Task 16 waits for all producers, GREEN
```

## Mandatory Data Flow Analysis Phase

**Execute BEFORE generating any task YAML.**

### Step 1: Extract Function/Type References

For each task description, identify:

**Functions called** (verbs suggest function usage):
- "Export metrics" → calls `ExtractMetrics()`
- "Load session data" → calls `LoadSession()`
- "Apply filters" → calls `ApplyFilters()`
- "Aggregate results" → calls `Aggregator.Process()`

**Types consumed** (nouns suggest type usage):
- "Display BehavioralMetrics" → uses `BehavioralMetrics` struct
- "Process SessionData" → uses `SessionData` struct
- "Format metrics output" → uses metrics types

**Patterns to detect:**

```
Keyword Pattern              → Likely Function/Type
─────────────────────────────────────────────────────
"export X"                   → calls X.Export() or FormatX()
"load/fetch/get X"           → calls LoadX(), GetX(), FetchX()
"display/show/render X"      → uses X as data source
"filter/search X"            → calls FilterX(), SearchX()
"aggregate/combine X"        → calls AggregateX(), uses Aggregator
"store/save/persist X"       → calls StoreX(), Save()
"process/transform X"        → calls ProcessX(), uses X as input
"integrate X with Y"         → calls both X and Y functions
```

### Step 2: Build Producer Registry

Map every function/type to its producing task:

```yaml
# Producer Registry (internal planning artifact)
producers:
  functions:
    ExtractMetrics:
      task: 4
      file: "internal/behavioral/extractor.go"
      signature: "func ExtractMetrics(data SessionData) *BehavioralMetrics"

    LoadSession:
      task: 5
      file: "internal/behavioral/aggregator.go"
      signature: "func (a *Aggregator) LoadSession(path string) error"

    ApplyFilters:
      task: 15
      file: "internal/behavioral/filter.go"
      signature: "func ApplyFilters(metrics *BehavioralMetrics, criteria FilterCriteria) *BehavioralMetrics"

  types:
    BehavioralMetrics:
      task: 1
      file: "internal/behavioral/models.go"

    SessionData:
      task: 2
      file: "internal/behavioral/parser.go"

    Aggregator:
      task: 5
      file: "internal/behavioral/aggregator.go"

    FilterCriteria:
      task: 15
      file: "internal/behavioral/filter.go"
```

### Step 3: Consumer Analysis

For each task, identify what it USES (not creates):

```yaml
# Consumer Analysis
task_16:
  description: "Add export functionality (JSON, Markdown, CSV)"

  consumes:
    functions:
      - name: ExtractMetrics
        producer: 4
        usage: "Get metrics from session data"

      - name: LoadSession
        producer: 5
        usage: "Load cached session for export"

      - name: ApplyFilters
        producer: 15
        usage: "Filter metrics before export"

    types:
      - name: BehavioralMetrics
        producer: 1
        usage: "Data structure to export"

  structural:
    - task: 13
      reason: "Registers as observe subcommand"

  # FINAL depends_on = all producers + structural
  depends_on: [1, 4, 5, 13, 15]
```

### Step 4: Dependency Validation

**Rule: Every consumer MUST depend_on its producers.**

```
Validation check:
  Task 16 consumes ExtractMetrics (Task 4)
  Task 16.depends_on includes 4?
    YES → PASS
    NO  → ERROR: Add depends_on: [4]

  Task 16 consumes LoadSession (Task 5)
  Task 16.depends_on includes 5?
    YES → PASS
    NO  → ERROR: Add depends_on: [5]
```

## Data Flow Registry Header

Add to generated plan for human visibility (YAML comment):

```yaml
# ═══════════════════════════════════════════════════════════════════════════
# DATA FLOW REGISTRY (Auto-generated by implementation-planner)
# ═══════════════════════════════════════════════════════════════════════════
#
# PRODUCERS (tasks that CREATE functions/types):
#   Task 1  → BehavioralMetrics, SessionData (models.go)
#   Task 2  → ParseSession() (parser.go)
#   Task 4  → ExtractMetrics() (extractor.go)
#   Task 5  → Aggregator, LoadSession() (aggregator.go)
#   Task 15 → ApplyFilters(), FilterCriteria (filter.go)
#
# CONSUMERS (tasks that USE functions/types):
#   Task 11 → ExtractMetrics [4], ApplyFilters [15]
#   Task 16 → ExtractMetrics [4], LoadSession [5], ApplyFilters [15]
#   Task 18 → Aggregator [5], BehavioralMetrics [1]
#
# DEPENDENCY VALIDATION:
#   ✓ Task 11: depends_on [4, 15] includes all producers
#   ✓ Task 16: depends_on [4, 5, 13, 15] includes all producers
#   ✓ Task 18: depends_on [1, 5, 17] includes all producers
#
# ═══════════════════════════════════════════════════════════════════════════
```

## Integration with Task Generation

### When Generating depends_on

```
1. Start with structural dependencies (framework integration):
   - Subcommand registration → parent command task
   - Package initialization → setup task

2. Add data flow dependencies (function/type producers):
   - Parse description for function calls
   - Look up producer in registry
   - Add producer task to depends_on

3. Validate completeness:
   - Every consumed function → producer in depends_on
   - Every consumed type → producer in depends_on
```

### Calls Section (Documentation Only)

Add to task YAML for human visibility (conductor ignores but humans see):

```yaml
- task_number: 16
  name: "Add export functionality"

  # Data flow documentation (conductor ignores, humans see)
  calls:
    - function: "ExtractMetrics"
      from_task: 4
      package: "internal/behavioral/extractor"
    - function: "LoadSession"
      from_task: 5
      package: "internal/behavioral/aggregator"
    - function: "ApplyFilters"
      from_task: 15
      package: "internal/behavioral/filter"

  # Actual dependency declaration (conductor uses)
  depends_on: [4, 5, 13, 15]
```

## Common Patterns

### Pattern 1: Data Pipeline

```
Parse → Extract → Aggregate → Export

Task 2 (Parse) produces: SessionData
Task 4 (Extract) consumes: SessionData, produces: BehavioralMetrics
Task 5 (Aggregate) consumes: BehavioralMetrics, produces: AggregatedMetrics
Task 16 (Export) consumes: BehavioralMetrics, AggregatedMetrics

depends_on chain:
  Task 2: []
  Task 4: [2]
  Task 5: [4]
  Task 16: [4, 5]  ← Must include ALL upstream producers
```

### Pattern 2: Fan-Out

```
One producer, multiple consumers:

Task 4 produces: ExtractMetrics()
  ↓
  ├→ Task 11 (stats display) - consumes ExtractMetrics
  ├→ Task 16 (export) - consumes ExtractMetrics
  └→ Task 18 (dashboard) - consumes ExtractMetrics

All consumers depend_on: [4]
```

### Pattern 3: Fan-In (Integration)

```
Multiple producers, one consumer:

Task 4 produces: ExtractMetrics()  ─┐
Task 5 produces: LoadSession()     ─┼→ Task 16 (export)
Task 15 produces: ApplyFilters()   ─┘

Task 16 depends_on: [4, 5, 15]  ← Must include ALL
```

### Pattern 4: Diamond Dependency

```
        Task 1 (models)
       /              \
      ↓                ↓
Task 4 (extract)   Task 5 (aggregate)
       \              /
        ↓            ↓
        Task 16 (export)

Task 16 depends_on: [1, 4, 5]  ← Include shared ancestor if directly used
```

## Red Flags During Analysis

### Flag 1: Consumer Without Producer

```
Task 16 calls DisplayMetrics() but no task produces it
→ Either:
   a) Add task to create DisplayMetrics()
   b) Task 16 creates it (update description)
```

### Flag 2: Wave Conflict

```
Task 16 in Wave 3 calls ExtractMetrics() from Task 4 in Wave 4
→ Task executes BEFORE dependency exists
→ Fix: Move Task 16 to Wave 5+ OR move Task 4 to Wave 2
```

### Flag 3: Placeholder Pattern

```
Description mentions "load from database" but no DB task in depends_on
→ Likely missing dependency
→ Add appropriate producer task to depends_on
```

### Flag 4: Empty Consumer

```
Task description vague: "Export functionality"
No specific functions mentioned
→ Ask: What SPECIFIC functions does export call?
→ Trace backwards to producers
```

## Quick Reference

```
ALWAYS ASK: "What functions does this task CALL?"
THEN ASK:   "Which task CREATES those functions?"
FINALLY:    "Are ALL producers in depends_on?"

Data flow beats feature grouping.
Producers must complete before consumers execute.
```

## Validation Checklist

Before finalizing any task:

- [ ] Identified all function calls in description
- [ ] Mapped each function to producing task
- [ ] All producers included in depends_on
- [ ] No wave conflicts (consumer after producer)
- [ ] Integration tasks depend on ALL wired components
- [ ] Data flow registry header added to plan
