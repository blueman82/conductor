package parser

import (
	"fmt"
	"io"
	"os"
	"strings"
	"time"

	"gopkg.in/yaml.v3"

	"github.com/harrison/conductor/internal/models"
)

// YAMLParser parses YAML format plans generated by /doc-yaml command
type YAMLParser struct{}

// yamlPlan represents the structure of a YAML plan file
type yamlPlan struct {
	Conductor            *yamlConductorConfig       `yaml:"conductor"`
	PlannerCompliance    *yamlPlannerComplianceSpec `yaml:"planner_compliance"`
	PlannerComplianceRaw map[string]interface{}     `yaml:"-"` // For unknown field validation
	DataFlowRegistry     *yamlDataFlowRegistry      `yaml:"data_flow_registry"`
	Plan                 struct {
		Metadata struct {
			FeatureName    string `yaml:"feature_name"`
			Created        string `yaml:"created"`
			EstimatedTasks int    `yaml:"estimated_tasks"`
		} `yaml:"metadata"`
		Tasks []yamlTask `yaml:"tasks"`
	} `yaml:"plan"`
}

// yamlPlannerComplianceSpec represents the planner compliance section (v2.9+)
type yamlPlannerComplianceSpec struct {
	PlannerVersion    string   `yaml:"planner_version"`
	StrictEnforcement bool     `yaml:"strict_enforcement"`
	RequiredFeatures  []string `yaml:"required_features"`
}

// yamlTask represents a single task in the YAML plan
type yamlTask struct {
	TaskNumber          interface{}          `yaml:"task_number"` // Accepts int, float, or string
	Name                string               `yaml:"name"`
	Files               []string             `yaml:"files"`
	DependsOn           []interface{}        `yaml:"depends_on"` // Accepts int, float, or string
	EstimatedTime       string               `yaml:"estimated_time"`
	Agent               string               `yaml:"agent"`
	WorktreeGroup       string               `yaml:"worktree_group"` // Worktree group for task organization
	Status              string               `yaml:"status"`
	CompletedDate       string               `yaml:"completed_date"` // Date format: YYYY-MM-DD
	CompletedAt         string               `yaml:"completed_at"`   // Timestamp format: RFC3339
	Description         string               `yaml:"description"`
	SuccessCriteria     interface{}          `yaml:"success_criteria"`     // Success criteria - supports both []string and []SuccessCriterion
	TestCommands        []string             `yaml:"test_commands"`        // Commands to run for verification
	Type                string               `yaml:"type"`                 // Task type: regular or integration
	IntegrationCriteria []string             `yaml:"integration_criteria"` // Criteria for integration tasks
	RuntimeMetadata     *yamlRuntimeMetadata `yaml:"runtime_metadata"`     // Runtime enforcement metadata (v2.9+)
	TestFirst           struct {
		TestFile        string   `yaml:"test_file"`
		Structure       []string `yaml:"structure"`
		TestStructure   string   `yaml:"test_structure"`
		TestSpecifics   string   `yaml:"test_specifics"`
		Mocks           []string `yaml:"mocks"`
		Fixtures        []string `yaml:"fixtures"`
		Assertions      []string `yaml:"assertions"`
		EdgeCases       []string `yaml:"edge_cases"`
		ExampleSkeleton string   `yaml:"example_skeleton"`
	} `yaml:"test_first"`
	Implementation struct {
		Approach      string `yaml:"approach"`
		CodeStructure string `yaml:"code_structure"`
		KeyPoints     []struct {
			Point     string `yaml:"point"`
			Details   string `yaml:"details"`
			Reference string `yaml:"reference"`
		} `yaml:"key_points"`
		Integration struct {
			Imports          []string `yaml:"imports"`
			ServicesToInject []string `yaml:"services_to_inject"`
			ConfigValues     []string `yaml:"config_values"`
			ErrorHandling    []string `yaml:"error_handling"`
		} `yaml:"integration"`
		IntegrationPoints []string `yaml:"integration_points"` // Legacy field
	} `yaml:"implementation"`
	Verification struct {
		ManualTesting []struct {
			Step     string `yaml:"step"`
			Command  string `yaml:"command"`
			Expected string `yaml:"expected"`
		} `yaml:"manual_testing"`
		AutomatedTests struct {
			Command        string `yaml:"command"`
			ExpectedOutput string `yaml:"expected_output"`
		} `yaml:"automated_tests"`
		SuccessCriteria []string `yaml:"success_criteria"`
		ExpectedOutput  string   `yaml:"expected_output"` // Legacy field
	} `yaml:"verification"`
	Commit struct {
		Type    string   `yaml:"type"`
		Message string   `yaml:"message"`
		Body    string   `yaml:"body"`
		Files   []string `yaml:"files"`
	} `yaml:"commit"`
}

// yamlConductorConfig represents the optional conductor configuration section in YAML
type yamlConductorConfig struct {
	DefaultAgent   string `yaml:"default_agent"`
	MaxConcurrency int    `yaml:"max_concurrency"`
	QualityControl struct {
		Enabled     bool   `yaml:"enabled"`
		ReviewAgent string `yaml:"review_agent"`
		RetryOnRed  int    `yaml:"retry_on_red"`
		Agents      struct {
			Mode              string   `yaml:"mode"`
			ExplicitList      []string `yaml:"explicit_list"`
			Additional        []string `yaml:"additional"`
			Blocked           []string `yaml:"blocked"`
			MaxAgents         int      `yaml:"max_agents"`
			CacheTTLSeconds   int      `yaml:"cache_ttl_seconds"`
			RequireCodeReview bool     `yaml:"require_code_review"`
		} `yaml:"agents"`
	} `yaml:"quality_control"`
	WorktreeGroups []struct {
		GroupID        string `yaml:"group_id"`
		Description    string `yaml:"description"`
		ExecutionModel string `yaml:"execution_model"`
		Isolation      string `yaml:"isolation"`
		Rationale      string `yaml:"rationale"`
	} `yaml:"worktree_groups"`
}

// yamlRuntimeMetadata represents task runtime metadata (v2.9+)
type yamlRuntimeMetadata struct {
	DependencyChecks     []yamlDependencyCheck     `yaml:"dependency_checks"`
	DocumentationTargets []yamlDocumentationTarget `yaml:"documentation_targets"`
	PromptBlocks         []yamlPromptBlock         `yaml:"prompt_blocks"`
}

// yamlDependencyCheck represents a dependency check command
type yamlDependencyCheck struct {
	Command     string `yaml:"command"`
	Description string `yaml:"description"`
}

// yamlDocumentationTarget represents a documentation location
type yamlDocumentationTarget struct {
	Location string `yaml:"location"`
	Section  string `yaml:"section"`
}

// yamlPromptBlock represents a structured prompt section
type yamlPromptBlock struct {
	Type    string `yaml:"type"`
	Content string `yaml:"content"`
}

// yamlSuccessCriterion represents a success criterion with optional verification
type yamlSuccessCriterion struct {
	Criterion    string                     `yaml:"criterion"`
	Verification *yamlCriterionVerification `yaml:"verification"`
}

// yamlCriterionVerification represents a verification block for a criterion
type yamlCriterionVerification struct {
	Command     string `yaml:"command"`
	Expected    string `yaml:"expected"`
	Description string `yaml:"description"`
}

// NewYAMLParser creates a new YAML parser instance
func NewYAMLParser() *YAMLParser {
	return &YAMLParser{}
}

// Parse parses a YAML plan from an io.Reader and returns a models.Plan
func (p *YAMLParser) Parse(r io.Reader) (*models.Plan, error) {
	// Read all content for multiple passes
	content, err := io.ReadAll(r)
	if err != nil {
		return nil, fmt.Errorf("failed to read content: %w", err)
	}

	var yp yamlPlan
	decoder := yaml.NewDecoder(strings.NewReader(string(content)))
	if err := decoder.Decode(&yp); err != nil {
		return nil, fmt.Errorf("failed to decode YAML: %w", err)
	}

	// Second pass: check for unknown fields in planner_compliance
	var rawPlan map[string]interface{}
	if err := yaml.Unmarshal(content, &rawPlan); err == nil {
		if pc, ok := rawPlan["planner_compliance"].(map[string]interface{}); ok {
			if err := ValidatePlannerComplianceFields(pc); err != nil {
				return nil, err
			}
		}
	}

	plan := &models.Plan{
		Name: yp.Plan.Metadata.FeatureName,
	}

	// Parse conductor config if present
	if yp.Conductor != nil {
		if err := parseConductorConfigYAML(yp.Conductor, plan); err != nil {
			return nil, fmt.Errorf("failed to parse conductor config: %w", err)
		}
	}

	// Parse planner compliance if present (v2.9+)
	if yp.PlannerCompliance != nil {
		if err := parsePlannerComplianceYAML(yp.PlannerCompliance, plan); err != nil {
			return nil, fmt.Errorf("failed to parse planner_compliance: %w", err)
		}
	}

	// Parse data flow registry if present (v2.9+)
	if yp.DataFlowRegistry != nil {
		registry, err := ParseDataFlowRegistry(yp.DataFlowRegistry)
		if err != nil {
			return nil, fmt.Errorf("failed to parse data_flow_registry: %w", err)
		}
		plan.DataFlowRegistry = registry
	}

	// Validate data flow registry requirements
	if IsDataFlowRegistryRequired(plan.PlannerCompliance) {
		if err := ValidateDataFlowRegistry(plan.DataFlowRegistry, true); err != nil {
			return nil, err
		}
	}

	// Convert YAML tasks to models.Task
	for i, yt := range yp.Plan.Tasks {
		taskNum, err := convertToString(yt.TaskNumber)
		if err != nil {
			return nil, fmt.Errorf("task %d: invalid task_number: %w", i+1, err)
		}

		// Process dependencies using the helper that supports mixed formats
		dependsOn, err := processDependencies(yt.DependsOn)
		if err != nil {
			return nil, fmt.Errorf("task %s: %w", taskNum, err)
		}

		// Parse success criteria (supports both []string and []SuccessCriterion)
		successCriteria, structuredCriteria, err := parseSuccessCriteria(yt.SuccessCriteria, taskNum)
		if err != nil {
			return nil, err
		}

		task := models.Task{
			Number:              taskNum,
			Name:                yt.Name,
			KeyPoints:           convertKeyPoints(yt.Implementation.KeyPoints),
			Files:               yt.Files,
			DependsOn:           dependsOn,
			Agent:               yt.Agent,
			WorktreeGroup:       yt.WorktreeGroup,
			Status:              yt.Status,
			SuccessCriteria:     successCriteria,
			StructuredCriteria:  structuredCriteria,
			TestCommands:        yt.TestCommands,
			Type:                yt.Type,
			IntegrationCriteria: yt.IntegrationCriteria,
		}

		// Parse runtime metadata if present (v2.9+)
		if yt.RuntimeMetadata != nil {
			task.RuntimeMetadata = parseRuntimeMetadata(yt.RuntimeMetadata)
		}

		// Parse estimated time
		if yt.EstimatedTime != "" {
			if dur, err := parseTimeString(yt.EstimatedTime); err == nil {
				task.EstimatedTime = dur
			}
		}

		// Parse completion timestamp from either completed_date or completed_at
		if yt.CompletedAt != "" {
			if t, err := parseCompletionTimestamp(yt.CompletedAt); err == nil {
				task.CompletedAt = &t
			}
		} else if yt.CompletedDate != "" {
			if t, err := parseCompletionDate(yt.CompletedDate); err == nil {
				task.CompletedAt = &t
			}
		}

		// Validate task type
		if err := ValidateTaskType(&task); err != nil {
			return nil, fmt.Errorf("task %s: %w", taskNum, err)
		}

		// Validate integration task requirements
		if err := ValidateIntegrationTask(&task); err != nil {
			return nil, fmt.Errorf("task %s: %w", taskNum, err)
		}

		// Parse commit specification if present
		if yt.Commit.Message != "" || yt.Commit.Type != "" || yt.Commit.Body != "" || len(yt.Commit.Files) > 0 {
			commitSpec := &models.CommitSpec{
				Type:    yt.Commit.Type,
				Message: yt.Commit.Message,
				Body:    yt.Commit.Body,
				Files:   yt.Commit.Files,
			}
			// Validate the commit spec
			if err := commitSpec.Validate(); err != nil {
				return nil, fmt.Errorf("task %s: invalid commit specification: %w", taskNum, err)
			}
			task.CommitSpec = commitSpec
		}

		// Build comprehensive prompt from all sections
		task.Prompt = buildPromptFromYAML(&yt)

		plan.Tasks = append(plan.Tasks, task)
	}

	// Validate runtime metadata requirements if strict enforcement is enabled
	if plan.PlannerCompliance != nil && plan.PlannerCompliance.StrictEnforcement {
		for _, task := range plan.Tasks {
			if task.RuntimeMetadata == nil {
				return nil, fmt.Errorf("task %s: runtime_metadata is required under strict enforcement", task.Number)
			}
		}
	}

	return plan, nil
}

// processDependencies converts a slice of mixed dependency formats (int, float, string, map)
// into normalized string representations. Supports:
// - Numeric dependencies: 1, 2.5, etc.
// - String dependencies: "1", "integration-1", etc.
// - Cross-file dependencies: {file: "plan-01.yaml", task: 2}
func processDependencies(deps []interface{}) ([]string, error) {
	var normalized []string

	for _, dep := range deps {
		switch v := dep.(type) {
		case int:
			normalized = append(normalized, fmt.Sprintf("%d", v))
		case float64:
			// YAML parses numbers as float64; check if it's a whole number
			if v == float64(int(v)) {
				normalized = append(normalized, fmt.Sprintf("%d", int(v)))
			} else {
				normalized = append(normalized, fmt.Sprintf("%v", v))
			}
		case string:
			normalized = append(normalized, v)
		case map[string]interface{}:
			// Parse cross-file dependency
			cfd, err := models.ParseCrossFileDep(buildCrossFileDepString(v))
			if err != nil {
				// Try to extract file and task from map directly
				file, hasFile := v["file"].(string)
				task, hasTask := v["task"]

				if !hasFile || !hasTask {
					// Return the original error message from models
					var fileErr, taskErr string
					if !hasFile {
						fileErr = "missing required 'file' field"
					}
					if !hasTask {
						if fileErr != "" {
							taskErr = " and missing required 'task' field"
						} else {
							taskErr = "missing required 'task' field"
						}
					}
					return nil, fmt.Errorf("cross-file dependency: %s%s", fileErr, taskErr)
				}

				// Convert task to string
				var taskStr string
				switch t := task.(type) {
				case int:
					taskStr = fmt.Sprintf("%d", t)
				case float64:
					if t == float64(int(t)) {
						taskStr = fmt.Sprintf("%d", int(t))
					} else {
						taskStr = fmt.Sprintf("%v", t)
					}
				case string:
					taskStr = t
				default:
					return nil, fmt.Errorf("cross-file dependency 'task' must be int/float/string, got %T", task)
				}

				normalized = append(normalized, fmt.Sprintf("file:%s:task:%s", file, taskStr))
			} else {
				normalized = append(normalized, cfd.String())
			}
		default:
			return nil, fmt.Errorf("invalid depends_on[%d]: unsupported type: %T", len(normalized), v)
		}
	}

	return normalized, nil
}

// buildCrossFileDepString converts a map representation to the standard string format
func buildCrossFileDepString(m map[string]interface{}) string {
	file, hasFile := m["file"].(string)
	task := m["task"]

	if !hasFile || task == nil {
		return ""
	}

	var taskStr string
	switch t := task.(type) {
	case int:
		taskStr = fmt.Sprintf("%d", t)
	case float64:
		if t == float64(int(t)) {
			taskStr = fmt.Sprintf("%d", int(t))
		} else {
			taskStr = fmt.Sprintf("%v", t)
		}
	case string:
		taskStr = t
	default:
		taskStr = fmt.Sprintf("%v", t)
	}

	return fmt.Sprintf("file:%s:task:%s", file, taskStr)
}

// convertKeyPoints normalizes YAML key_point entries into model KeyPoints
func convertKeyPoints(src []struct {
	Point     string `yaml:"point"`
	Details   string `yaml:"details"`
	Reference string `yaml:"reference"`
}) []models.KeyPoint {
	var keyPoints []models.KeyPoint
	for _, kp := range src {
		trimmedPoint := strings.TrimSpace(kp.Point)
		if trimmedPoint == "" {
			continue
		}
		keyPoints = append(keyPoints, models.KeyPoint{
			Point:     trimmedPoint,
			Details:   strings.TrimSpace(kp.Details),
			Reference: strings.TrimSpace(kp.Reference),
		})
	}

	if len(keyPoints) == 0 {
		return nil
	}
	return keyPoints
}

// convertToString converts interface{} to string, supporting int, float, and string types
func convertToString(val interface{}) (string, error) {
	if val == nil {
		return "", fmt.Errorf("value is nil")
	}

	switch v := val.(type) {
	case string:
		return v, nil
	case int:
		return fmt.Sprintf("%d", v), nil
	case int64:
		return fmt.Sprintf("%d", v), nil
	case float64:
		// Check if it's a whole number
		if v == float64(int64(v)) {
			return fmt.Sprintf("%d", int64(v)), nil
		}
		return fmt.Sprintf("%g", v), nil
	case float32:
		// Check if it's a whole number
		if v == float32(int64(v)) {
			return fmt.Sprintf("%d", int64(v)), nil
		}
		return fmt.Sprintf("%g", v), nil
	default:
		return "", fmt.Errorf("unsupported type: %T", val)
	}
}

// parseConductorConfigYAML parses the conductor configuration section
func parseConductorConfigYAML(cfg *yamlConductorConfig, plan *models.Plan) error {
	plan.DefaultAgent = cfg.DefaultAgent

	plan.QualityControl = models.QualityControlConfig{
		Enabled:     cfg.QualityControl.Enabled,
		ReviewAgent: cfg.QualityControl.ReviewAgent,
		RetryOnRed:  cfg.QualityControl.RetryOnRed,
	}

	// Parse QC agent configuration if present
	if cfg.QualityControl.Agents.Mode != "" || len(cfg.QualityControl.Agents.ExplicitList) > 0 ||
		len(cfg.QualityControl.Agents.Additional) > 0 || len(cfg.QualityControl.Agents.Blocked) > 0 {

		// Normalize and validate mode
		mode := strings.ToLower(strings.TrimSpace(cfg.QualityControl.Agents.Mode))
		validModes := map[string]bool{"auto": true, "explicit": true, "mixed": true, "intelligent": true, "": true}
		if !validModes[mode] {
			return fmt.Errorf("invalid QC agents mode: %q", mode)
		}

		// Explicit mode requires explicit_list
		if mode == "explicit" && len(cfg.QualityControl.Agents.ExplicitList) == 0 {
			return fmt.Errorf("explicit mode requires non-empty explicit_list")
		}

		plan.QualityControl.Agents = models.QCAgentConfig{
			Mode:              mode,
			ExplicitList:      cfg.QualityControl.Agents.ExplicitList,
			AdditionalAgents:  cfg.QualityControl.Agents.Additional,
			BlockedAgents:     cfg.QualityControl.Agents.Blocked,
			MaxAgents:         cfg.QualityControl.Agents.MaxAgents,
			CacheTTLSeconds:   cfg.QualityControl.Agents.CacheTTLSeconds,
			RequireCodeReview: cfg.QualityControl.Agents.RequireCodeReview,
		}
	}

	// Parse worktree groups
	for _, yg := range cfg.WorktreeGroups {
		group := models.WorktreeGroup{
			GroupID:        yg.GroupID,
			Description:    yg.Description,
			ExecutionModel: yg.ExecutionModel,
			Isolation:      yg.Isolation,
			Rationale:      yg.Rationale,
		}
		plan.WorktreeGroups = append(plan.WorktreeGroups, group)
	}

	return nil
}

// buildPromptFromYAML constructs a comprehensive prompt from all YAML task sections
func buildPromptFromYAML(yt *yamlTask) string {
	var prompt strings.Builder

	// Task header
	taskNum, _ := convertToString(yt.TaskNumber)
	fmt.Fprintf(&prompt, "# Task %s: %s\n\n", taskNum, yt.Name)

	// Target files - CRITICAL: tells agent exactly which files to create/modify
	if len(yt.Files) > 0 {
		fmt.Fprintf(&prompt, "## Target Files (REQUIRED)\n\n")
		fmt.Fprintf(&prompt, "**You MUST create/modify these exact files:**\n")
		for _, file := range yt.Files {
			fmt.Fprintf(&prompt, "- `%s`\n", file)
		}
		fmt.Fprintf(&prompt, "\n⚠️ Do NOT create files with different names or paths. Use the exact paths listed above.\n\n")
	}

	// Description
	if yt.Description != "" {
		fmt.Fprintf(&prompt, "## Description\n\n%s\n\n", strings.TrimSpace(yt.Description))
	}

	// Test First section
	if yt.TestFirst.TestFile != "" || len(yt.TestFirst.Structure) > 0 ||
		yt.TestFirst.TestStructure != "" || yt.TestFirst.TestSpecifics != "" ||
		len(yt.TestFirst.Mocks) > 0 || len(yt.TestFirst.Fixtures) > 0 ||
		len(yt.TestFirst.Assertions) > 0 || len(yt.TestFirst.EdgeCases) > 0 ||
		yt.TestFirst.ExampleSkeleton != "" {
		fmt.Fprintf(&prompt, "## Test First (TDD)\n\n")

		if yt.TestFirst.TestFile != "" {
			fmt.Fprintf(&prompt, "**Test file**: `%s`\n\n", yt.TestFirst.TestFile)
		}

		// Handle both structure array and test_structure string
		if len(yt.TestFirst.Structure) > 0 {
			fmt.Fprintf(&prompt, "**Test structure**:\n")
			for _, item := range yt.TestFirst.Structure {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(item))
			}
			fmt.Fprintf(&prompt, "\n")
		} else if yt.TestFirst.TestStructure != "" {
			fmt.Fprintf(&prompt, "**Test structure**:\n%s\n\n", strings.TrimSpace(yt.TestFirst.TestStructure))
		}

		if len(yt.TestFirst.Mocks) > 0 {
			fmt.Fprintf(&prompt, "**Mocks**:\n")
			for _, mock := range yt.TestFirst.Mocks {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(mock))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.TestFirst.Fixtures) > 0 {
			fmt.Fprintf(&prompt, "**Fixtures**:\n")
			for _, fixture := range yt.TestFirst.Fixtures {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(fixture))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.TestFirst.Assertions) > 0 {
			fmt.Fprintf(&prompt, "**Assertions**:\n")
			for _, assertion := range yt.TestFirst.Assertions {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(assertion))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.TestFirst.EdgeCases) > 0 {
			fmt.Fprintf(&prompt, "**Edge cases**:\n")
			for _, edgeCase := range yt.TestFirst.EdgeCases {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(edgeCase))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if yt.TestFirst.TestSpecifics != "" {
			fmt.Fprintf(&prompt, "**Test specifics**:\n%s\n\n", strings.TrimSpace(yt.TestFirst.TestSpecifics))
		}

		if yt.TestFirst.ExampleSkeleton != "" {
			fmt.Fprintf(&prompt, "**Example test skeleton**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.TestFirst.ExampleSkeleton))
		}
	}

	// Implementation section
	hasImplementation := yt.Implementation.Approach != "" || yt.Implementation.CodeStructure != "" ||
		len(yt.Implementation.KeyPoints) > 0 ||
		len(yt.Implementation.Integration.Imports) > 0 ||
		len(yt.Implementation.Integration.ErrorHandling) > 0 ||
		len(yt.Implementation.IntegrationPoints) > 0

	if hasImplementation {
		fmt.Fprintf(&prompt, "## Implementation\n\n")

		if yt.Implementation.Approach != "" {
			fmt.Fprintf(&prompt, "**Approach**:\n%s\n\n", strings.TrimSpace(yt.Implementation.Approach))
		}

		if yt.Implementation.CodeStructure != "" {
			fmt.Fprintf(&prompt, "**Code structure**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.Implementation.CodeStructure))
		}

		// Handle key_points as array of objects
		if len(yt.Implementation.KeyPoints) > 0 {
			fmt.Fprintf(&prompt, "**Key points**:\n")
			for _, kp := range yt.Implementation.KeyPoints {
				if kp.Point != "" {
					fmt.Fprintf(&prompt, "- %s", strings.TrimSpace(kp.Point))
					if kp.Details != "" {
						fmt.Fprintf(&prompt, ": %s", strings.TrimSpace(kp.Details))
					}
					if kp.Reference != "" {
						fmt.Fprintf(&prompt, " (ref: %s)", strings.TrimSpace(kp.Reference))
					}
					fmt.Fprintf(&prompt, "\n")
				}
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Handle integration object
		hasIntegration := len(yt.Implementation.Integration.Imports) > 0 ||
			len(yt.Implementation.Integration.ServicesToInject) > 0 ||
			len(yt.Implementation.Integration.ConfigValues) > 0 ||
			len(yt.Implementation.Integration.ErrorHandling) > 0

		if hasIntegration {
			fmt.Fprintf(&prompt, "**Integration**:\n")

			if len(yt.Implementation.Integration.Imports) > 0 {
				fmt.Fprintf(&prompt, "- Imports: %s\n", strings.Join(yt.Implementation.Integration.Imports, ", "))
			}
			if len(yt.Implementation.Integration.ServicesToInject) > 0 {
				fmt.Fprintf(&prompt, "- Services to inject: %s\n", strings.Join(yt.Implementation.Integration.ServicesToInject, ", "))
			}
			if len(yt.Implementation.Integration.ConfigValues) > 0 {
				fmt.Fprintf(&prompt, "- Config values: %s\n", strings.Join(yt.Implementation.Integration.ConfigValues, ", "))
			}
			if len(yt.Implementation.Integration.ErrorHandling) > 0 {
				fmt.Fprintf(&prompt, "- Error handling:\n")
				for _, eh := range yt.Implementation.Integration.ErrorHandling {
					fmt.Fprintf(&prompt, "  - %s\n", strings.TrimSpace(eh))
				}
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Legacy integration_points field
		if len(yt.Implementation.IntegrationPoints) > 0 {
			fmt.Fprintf(&prompt, "**Integration points**:\n")
			for _, point := range yt.Implementation.IntegrationPoints {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(point))
			}
			fmt.Fprintf(&prompt, "\n")
		}
	}

	// Verification section
	hasVerification := len(yt.Verification.ManualTesting) > 0 ||
		yt.Verification.AutomatedTests.Command != "" ||
		len(yt.Verification.SuccessCriteria) > 0 ||
		yt.Verification.ExpectedOutput != ""

	if hasVerification {
		fmt.Fprintf(&prompt, "## Verification\n\n")

		// Handle manual_testing as array of objects
		if len(yt.Verification.ManualTesting) > 0 {
			fmt.Fprintf(&prompt, "**Manual testing**:\n")
			for i, mt := range yt.Verification.ManualTesting {
				if mt.Step != "" {
					fmt.Fprintf(&prompt, "%d. %s", i+1, strings.TrimSpace(mt.Step))
					if mt.Command != "" {
						fmt.Fprintf(&prompt, "\n   Command: `%s`", strings.TrimSpace(mt.Command))
					}
					if mt.Expected != "" {
						fmt.Fprintf(&prompt, "\n   Expected: %s", strings.TrimSpace(mt.Expected))
					}
					fmt.Fprintf(&prompt, "\n")
				}
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Handle automated_tests as object
		if yt.Verification.AutomatedTests.Command != "" {
			fmt.Fprintf(&prompt, "**Automated tests**:\n```bash\n%s\n```\n", strings.TrimSpace(yt.Verification.AutomatedTests.Command))
			if yt.Verification.AutomatedTests.ExpectedOutput != "" {
				fmt.Fprintf(&prompt, "\n**Expected output**:\n```\n%s\n```\n", strings.TrimSpace(yt.Verification.AutomatedTests.ExpectedOutput))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.Verification.SuccessCriteria) > 0 {
			fmt.Fprintf(&prompt, "**Success criteria**:\n")
			for _, criterion := range yt.Verification.SuccessCriteria {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(criterion))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Legacy expected_output field
		if yt.Verification.ExpectedOutput != "" && yt.Verification.AutomatedTests.ExpectedOutput == "" {
			fmt.Fprintf(&prompt, "**Expected output**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.Verification.ExpectedOutput))
		}
	}

	// Commit section - informational reference
	if yt.Commit.Message != "" {
		fmt.Fprintf(&prompt, "## Commit\n\n")
		if yt.Commit.Type != "" {
			fmt.Fprintf(&prompt, "**Type**: %s\n", yt.Commit.Type)
		}
		fmt.Fprintf(&prompt, "**Message**: %s\n", strings.TrimSpace(yt.Commit.Message))
		if yt.Commit.Body != "" {
			fmt.Fprintf(&prompt, "\n**Body**:\n%s\n", strings.TrimSpace(yt.Commit.Body))
		}
		if len(yt.Commit.Files) > 0 {
			fmt.Fprintf(&prompt, "\n**Files**:\n")
			for _, file := range yt.Commit.Files {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(file))
			}
		}
		fmt.Fprintf(&prompt, "\n")

		// MANDATORY COMMIT section - imperative instructions for the agent
		fmt.Fprintf(&prompt, "---\n\n")
		fmt.Fprintf(&prompt, "## MANDATORY COMMIT (REQUIRED)\n\n")
		fmt.Fprintf(&prompt, "After completing your changes, you MUST commit them to git:\n\n")

		// Build the commit message using CommitSpec logic
		commitSpec := &models.CommitSpec{
			Type:    yt.Commit.Type,
			Message: yt.Commit.Message,
			Body:    yt.Commit.Body,
			Files:   yt.Commit.Files,
		}
		commitMessage := commitSpec.BuildCommitMessage()

		// Step 1: Stage files
		if len(yt.Commit.Files) > 0 {
			fmt.Fprintf(&prompt, "1. Stage the following files:\n")
			for _, file := range yt.Commit.Files {
				fmt.Fprintf(&prompt, "   - %s\n", strings.TrimSpace(file))
			}
			fmt.Fprintf(&prompt, "\n")
		} else {
			fmt.Fprintf(&prompt, "1. Stage your modified files.\n\n")
		}

		// Step 2: Create commit with exact message
		fmt.Fprintf(&prompt, "2. Create commit with this EXACT message:\n")
		fmt.Fprintf(&prompt, "   %s\n\n", commitMessage)

		// Step 3: Example git commands
		fmt.Fprintf(&prompt, "3. Use these commands:\n")
		if len(yt.Commit.Files) > 0 {
			fmt.Fprintf(&prompt, "   git add %s\n", strings.Join(yt.Commit.Files, " "))
		} else {
			fmt.Fprintf(&prompt, "   git add <your-modified-files>\n")
		}
		fmt.Fprintf(&prompt, "   git commit -m \"%s\"\n\n", commitMessage)

		// Warning about task completion
		fmt.Fprintf(&prompt, "⚠️ Your task is NOT complete until changes are committed.\n\n")
	}

	return prompt.String()
}

// parseTimeString parses time duration strings like "30m", "1h", "2h30m"
func parseTimeString(s string) (time.Duration, error) {
	// time.ParseDuration already handles formats like "30m", "1h", "2h30m"
	return time.ParseDuration(s)
}

// parseCompletionDate parses a date string in format "YYYY-MM-DD" and returns a time.Time
func parseCompletionDate(dateStr string) (time.Time, error) {
	return time.Parse("2006-01-02", dateStr)
}

// parseCompletionTimestamp parses a timestamp string in RFC3339 format and returns a time.Time
func parseCompletionTimestamp(timestampStr string) (time.Time, error) {
	return time.Parse(time.RFC3339, timestampStr)
}

// parsePlannerComplianceYAML parses planner compliance configuration (v2.9+)
func parsePlannerComplianceYAML(cfg *yamlPlannerComplianceSpec, plan *models.Plan) error {
	// Validate required planner_version
	if cfg.PlannerVersion == "" {
		return fmt.Errorf("planner_compliance: planner_version is required")
	}

	plan.PlannerCompliance = &models.PlannerComplianceSpec{
		PlannerVersion:    cfg.PlannerVersion,
		StrictEnforcement: cfg.StrictEnforcement,
		RequiredFeatures:  cfg.RequiredFeatures,
	}

	return nil
}

// parseRuntimeMetadata converts yamlRuntimeMetadata to models.TaskMetadataRuntime
func parseRuntimeMetadata(yrm *yamlRuntimeMetadata) *models.TaskMetadataRuntime {
	rm := &models.TaskMetadataRuntime{
		DependencyChecks:     make([]models.DependencyCheck, 0, len(yrm.DependencyChecks)),
		DocumentationTargets: make([]models.DocumentationTarget, 0, len(yrm.DocumentationTargets)),
		PromptBlocks:         make([]models.PromptBlock, 0, len(yrm.PromptBlocks)),
	}

	for _, dc := range yrm.DependencyChecks {
		rm.DependencyChecks = append(rm.DependencyChecks, models.DependencyCheck{
			Command:     dc.Command,
			Description: dc.Description,
		})
	}

	for _, dt := range yrm.DocumentationTargets {
		rm.DocumentationTargets = append(rm.DocumentationTargets, models.DocumentationTarget{
			Location: dt.Location,
			Section:  dt.Section,
		})
	}

	for _, pb := range yrm.PromptBlocks {
		rm.PromptBlocks = append(rm.PromptBlocks, models.PromptBlock{
			Type:    pb.Type,
			Content: pb.Content,
		})
	}

	return rm
}

// parseSuccessCriteria parses success criteria which can be either []string or []SuccessCriterion
// Returns both the legacy string array and the new structured criteria array
func parseSuccessCriteria(input interface{}, taskNum string) ([]string, []models.SuccessCriterion, error) {
	if input == nil {
		return nil, nil, nil
	}

	// Try parsing as []interface{} which could be either strings or structured objects
	items, ok := input.([]interface{})
	if !ok {
		return nil, nil, fmt.Errorf("task %s: success_criteria must be an array", taskNum)
	}

	var legacyCriteria []string
	var structuredCriteria []models.SuccessCriterion

	for i, item := range items {
		switch v := item.(type) {
		case string:
			// Legacy format: simple string
			legacyCriteria = append(legacyCriteria, v)
			structuredCriteria = append(structuredCriteria, models.SuccessCriterion{
				Criterion: v,
			})
		case map[string]interface{}:
			// Structured format with criterion and optional verification
			criterion, ok := v["criterion"].(string)
			if !ok {
				return nil, nil, fmt.Errorf("task %s: success_criteria[%d]: criterion must be a string", taskNum, i)
			}

			sc := models.SuccessCriterion{
				Criterion: criterion,
			}
			legacyCriteria = append(legacyCriteria, criterion)

			// Parse optional verification block
			if verif, hasVerif := v["verification"]; hasVerif && verif != nil {
				verifMap, ok := verif.(map[string]interface{})
				if !ok {
					return nil, nil, fmt.Errorf("task %s: success_criteria[%d]: verification must be an object", taskNum, i)
				}

				cv := &models.CriterionVerification{}
				if cmd, ok := verifMap["command"].(string); ok {
					cv.Command = cmd
				}
				if exp, ok := verifMap["expected"].(string); ok {
					cv.Expected = exp
				}
				if desc, ok := verifMap["description"].(string); ok {
					cv.Description = desc
				}

				// Validate verification block has command
				if cv.Command == "" {
					return nil, nil, fmt.Errorf("task %s: success_criteria[%d]: verification command cannot be empty", taskNum, i)
				}

				sc.Verification = cv
			}

			structuredCriteria = append(structuredCriteria, sc)
		default:
			return nil, nil, fmt.Errorf("task %s: success_criteria[%d]: unsupported type %T", taskNum, i, v)
		}
	}

	return legacyCriteria, structuredCriteria, nil
}

// ParseFile parses a YAML plan file and returns a models.Plan
func (p *YAMLParser) ParseFile(path string) (*models.Plan, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open file %s: %w", path, err)
	}
	defer file.Close()
	return p.Parse(file)
}
