package parser

import (
	"fmt"
	"io"
	"strings"
	"time"

	"gopkg.in/yaml.v3"

	"github.com/harrison/conductor/internal/models"
)

// YAMLParser parses YAML format plans generated by /doc-yaml command
type YAMLParser struct{}

// yamlPlan represents the structure of a YAML plan file
type yamlPlan struct {
	Conductor *yamlConductorConfig `yaml:"conductor"`
	Plan      struct {
		Metadata struct {
			FeatureName    string `yaml:"feature_name"`
			Created        string `yaml:"created"`
			EstimatedTasks int    `yaml:"estimated_tasks"`
		} `yaml:"metadata"`
		Tasks []yamlTask `yaml:"tasks"`
	} `yaml:"plan"`
}

// yamlTask represents a single task in the YAML plan
type yamlTask struct {
	TaskNumber          interface{}   `yaml:"task_number"` // Accepts int, float, or string
	Name                string        `yaml:"name"`
	Files               []string      `yaml:"files"`
	DependsOn           []interface{} `yaml:"depends_on"` // Accepts int, float, or string
	EstimatedTime       string        `yaml:"estimated_time"`
	Agent               string        `yaml:"agent"`
	WorktreeGroup       string        `yaml:"worktree_group"` // Worktree group for task organization
	Status              string        `yaml:"status"`
	CompletedDate       string        `yaml:"completed_date"` // Date format: YYYY-MM-DD
	CompletedAt         string        `yaml:"completed_at"`   // Timestamp format: RFC3339
	Description         string        `yaml:"description"`
	SuccessCriteria     []string      `yaml:"success_criteria"`     // Success criteria for task verification
	TestCommands        []string      `yaml:"test_commands"`        // Commands to run for verification
	Type                string        `yaml:"type"`                 // Task type: regular or integration
	IntegrationCriteria []string      `yaml:"integration_criteria"` // Criteria for integration tasks
	TestFirst           struct {
		TestFile        string   `yaml:"test_file"`
		Structure       []string `yaml:"structure"`
		TestStructure   string   `yaml:"test_structure"`
		TestSpecifics   string   `yaml:"test_specifics"`
		Mocks           []string `yaml:"mocks"`
		Fixtures        []string `yaml:"fixtures"`
		Assertions      []string `yaml:"assertions"`
		EdgeCases       []string `yaml:"edge_cases"`
		ExampleSkeleton string   `yaml:"example_skeleton"`
	} `yaml:"test_first"`
	Implementation struct {
		Approach      string `yaml:"approach"`
		CodeStructure string `yaml:"code_structure"`
		KeyPoints     []struct {
			Point     string `yaml:"point"`
			Details   string `yaml:"details"`
			Reference string `yaml:"reference"`
		} `yaml:"key_points"`
		Integration struct {
			Imports          []string `yaml:"imports"`
			ServicesToInject []string `yaml:"services_to_inject"`
			ConfigValues     []string `yaml:"config_values"`
			ErrorHandling    []string `yaml:"error_handling"`
		} `yaml:"integration"`
		IntegrationPoints []string `yaml:"integration_points"` // Legacy field
	} `yaml:"implementation"`
	Verification struct {
		ManualTesting []struct {
			Step     string `yaml:"step"`
			Command  string `yaml:"command"`
			Expected string `yaml:"expected"`
		} `yaml:"manual_testing"`
		AutomatedTests struct {
			Command        string `yaml:"command"`
			ExpectedOutput string `yaml:"expected_output"`
		} `yaml:"automated_tests"`
		SuccessCriteria []string `yaml:"success_criteria"`
		ExpectedOutput  string   `yaml:"expected_output"` // Legacy field
	} `yaml:"verification"`
	Commit struct {
		Type    string   `yaml:"type"`
		Message string   `yaml:"message"`
		Body    string   `yaml:"body"`
		Files   []string `yaml:"files"`
	} `yaml:"commit"`
}

// yamlConductorConfig represents the optional conductor configuration section in YAML
type yamlConductorConfig struct {
	DefaultAgent   string `yaml:"default_agent"`
	MaxConcurrency int    `yaml:"max_concurrency"`
	QualityControl struct {
		Enabled     bool   `yaml:"enabled"`
		ReviewAgent string `yaml:"review_agent"`
		RetryOnRed  int    `yaml:"retry_on_red"`
		Agents      struct {
			Mode              string   `yaml:"mode"`
			ExplicitList      []string `yaml:"explicit_list"`
			Additional        []string `yaml:"additional"`
			Blocked           []string `yaml:"blocked"`
			MaxAgents         int      `yaml:"max_agents"`
			CacheTTLSeconds   int      `yaml:"cache_ttl_seconds"`
			RequireCodeReview bool     `yaml:"require_code_review"`
		} `yaml:"agents"`
	} `yaml:"quality_control"`
	WorktreeGroups []struct {
		GroupID        string `yaml:"group_id"`
		Description    string `yaml:"description"`
		ExecutionModel string `yaml:"execution_model"`
		Isolation      string `yaml:"isolation"`
		Rationale      string `yaml:"rationale"`
	} `yaml:"worktree_groups"`
}

// NewYAMLParser creates a new YAML parser instance
func NewYAMLParser() *YAMLParser {
	return &YAMLParser{}
}

// Parse parses a YAML plan from an io.Reader and returns a models.Plan
func (p *YAMLParser) Parse(r io.Reader) (*models.Plan, error) {
	var yp yamlPlan
	decoder := yaml.NewDecoder(r)
	if err := decoder.Decode(&yp); err != nil {
		return nil, fmt.Errorf("failed to decode YAML: %w", err)
	}

	plan := &models.Plan{
		Name: yp.Plan.Metadata.FeatureName,
	}

	// Parse conductor config if present
	if yp.Conductor != nil {
		if err := parseConductorConfigYAML(yp.Conductor, plan); err != nil {
			return nil, fmt.Errorf("failed to parse conductor config: %w", err)
		}
	}

	// Convert YAML tasks to models.Task
	for i, yt := range yp.Plan.Tasks {
		taskNum, err := convertToString(yt.TaskNumber)
		if err != nil {
			return nil, fmt.Errorf("task %d: invalid task_number: %w", i+1, err)
		}

		// Process dependencies using the helper that supports mixed formats
		dependsOn, err := processDependencies(yt.DependsOn)
		if err != nil {
			return nil, fmt.Errorf("task %s: %w", taskNum, err)
		}

		task := models.Task{
			Number:              taskNum,
			Name:                yt.Name,
			KeyPoints:           convertKeyPoints(yt.Implementation.KeyPoints),
			Files:               yt.Files,
			DependsOn:           dependsOn,
			Agent:               yt.Agent,
			WorktreeGroup:       yt.WorktreeGroup,
			Status:              yt.Status,
			SuccessCriteria:     yt.SuccessCriteria,
			TestCommands:        yt.TestCommands,
			Type:                yt.Type,
			IntegrationCriteria: yt.IntegrationCriteria,
		}

		// Parse estimated time
		if yt.EstimatedTime != "" {
			if dur, err := parseTimeString(yt.EstimatedTime); err == nil {
				task.EstimatedTime = dur
			}
		}

		// Parse completion timestamp from either completed_date or completed_at
		if yt.CompletedAt != "" {
			if t, err := parseCompletionTimestamp(yt.CompletedAt); err == nil {
				task.CompletedAt = &t
			}
		} else if yt.CompletedDate != "" {
			if t, err := parseCompletionDate(yt.CompletedDate); err == nil {
				task.CompletedAt = &t
			}
		}

		// Validate task type
		if err := ValidateTaskType(&task); err != nil {
			return nil, fmt.Errorf("task %s: %w", taskNum, err)
		}

		// Validate integration task requirements
		if err := ValidateIntegrationTask(&task); err != nil {
			return nil, fmt.Errorf("task %s: %w", taskNum, err)
		}

		// Build comprehensive prompt from all sections
		task.Prompt = buildPromptFromYAML(&yt)

		plan.Tasks = append(plan.Tasks, task)
	}

	return plan, nil
}

// processDependencies converts a slice of mixed dependency formats (int, float, string, map)
// into normalized string representations. Supports:
// - Numeric dependencies: 1, 2.5, etc.
// - String dependencies: "1", "integration-1", etc.
// - Cross-file dependencies: {file: "plan-01.yaml", task: 2}
func processDependencies(deps []interface{}) ([]string, error) {
	var normalized []string

	for _, dep := range deps {
		switch v := dep.(type) {
		case int:
			normalized = append(normalized, fmt.Sprintf("%d", v))
		case float64:
			// YAML parses numbers as float64; check if it's a whole number
			if v == float64(int(v)) {
				normalized = append(normalized, fmt.Sprintf("%d", int(v)))
			} else {
				normalized = append(normalized, fmt.Sprintf("%v", v))
			}
		case string:
			normalized = append(normalized, v)
		case map[string]interface{}:
			// Parse cross-file dependency
			cfd, err := models.ParseCrossFileDep(buildCrossFileDepString(v))
			if err != nil {
				// Try to extract file and task from map directly
				file, hasFile := v["file"].(string)
				task, hasTask := v["task"]

				if !hasFile || !hasTask {
					// Return the original error message from models
					var fileErr, taskErr string
					if !hasFile {
						fileErr = "missing required 'file' field"
					}
					if !hasTask {
						if fileErr != "" {
							taskErr = " and missing required 'task' field"
						} else {
							taskErr = "missing required 'task' field"
						}
					}
					return nil, fmt.Errorf("cross-file dependency: %s%s", fileErr, taskErr)
				}

				// Convert task to string
				var taskStr string
				switch t := task.(type) {
				case int:
					taskStr = fmt.Sprintf("%d", t)
				case float64:
					if t == float64(int(t)) {
						taskStr = fmt.Sprintf("%d", int(t))
					} else {
						taskStr = fmt.Sprintf("%v", t)
					}
				case string:
					taskStr = t
				default:
					return nil, fmt.Errorf("cross-file dependency 'task' must be int/float/string, got %T", task)
				}

				normalized = append(normalized, fmt.Sprintf("file:%s:task:%s", file, taskStr))
			} else {
				normalized = append(normalized, cfd.String())
			}
		default:
			return nil, fmt.Errorf("invalid depends_on[%d]: unsupported type: %T", len(normalized), v)
		}
	}

	return normalized, nil
}

// buildCrossFileDepString converts a map representation to the standard string format
func buildCrossFileDepString(m map[string]interface{}) string {
	file, hasFile := m["file"].(string)
	task := m["task"]

	if !hasFile || task == nil {
		return ""
	}

	var taskStr string
	switch t := task.(type) {
	case int:
		taskStr = fmt.Sprintf("%d", t)
	case float64:
		if t == float64(int(t)) {
			taskStr = fmt.Sprintf("%d", int(t))
		} else {
			taskStr = fmt.Sprintf("%v", t)
		}
	case string:
		taskStr = t
	default:
		taskStr = fmt.Sprintf("%v", t)
	}

	return fmt.Sprintf("file:%s:task:%s", file, taskStr)
}

// convertKeyPoints normalizes YAML key_point entries into model KeyPoints
func convertKeyPoints(src []struct {
	Point     string `yaml:"point"`
	Details   string `yaml:"details"`
	Reference string `yaml:"reference"`
}) []models.KeyPoint {
	var keyPoints []models.KeyPoint
	for _, kp := range src {
		trimmedPoint := strings.TrimSpace(kp.Point)
		if trimmedPoint == "" {
			continue
		}
		keyPoints = append(keyPoints, models.KeyPoint{
			Point:     trimmedPoint,
			Details:   strings.TrimSpace(kp.Details),
			Reference: strings.TrimSpace(kp.Reference),
		})
	}

	if len(keyPoints) == 0 {
		return nil
	}
	return keyPoints
}

// convertToString converts interface{} to string, supporting int, float, and string types
func convertToString(val interface{}) (string, error) {
	if val == nil {
		return "", fmt.Errorf("value is nil")
	}

	switch v := val.(type) {
	case string:
		return v, nil
	case int:
		return fmt.Sprintf("%d", v), nil
	case int64:
		return fmt.Sprintf("%d", v), nil
	case float64:
		// Check if it's a whole number
		if v == float64(int64(v)) {
			return fmt.Sprintf("%d", int64(v)), nil
		}
		return fmt.Sprintf("%g", v), nil
	case float32:
		// Check if it's a whole number
		if v == float32(int64(v)) {
			return fmt.Sprintf("%d", int64(v)), nil
		}
		return fmt.Sprintf("%g", v), nil
	default:
		return "", fmt.Errorf("unsupported type: %T", val)
	}
}

// parseConductorConfigYAML parses the conductor configuration section
func parseConductorConfigYAML(cfg *yamlConductorConfig, plan *models.Plan) error {
	plan.DefaultAgent = cfg.DefaultAgent

	plan.QualityControl = models.QualityControlConfig{
		Enabled:     cfg.QualityControl.Enabled,
		ReviewAgent: cfg.QualityControl.ReviewAgent,
		RetryOnRed:  cfg.QualityControl.RetryOnRed,
	}

	// Parse QC agent configuration if present
	if cfg.QualityControl.Agents.Mode != "" || len(cfg.QualityControl.Agents.ExplicitList) > 0 ||
		len(cfg.QualityControl.Agents.Additional) > 0 || len(cfg.QualityControl.Agents.Blocked) > 0 {

		// Normalize and validate mode
		mode := strings.ToLower(strings.TrimSpace(cfg.QualityControl.Agents.Mode))
		validModes := map[string]bool{"auto": true, "explicit": true, "mixed": true, "intelligent": true, "": true}
		if !validModes[mode] {
			return fmt.Errorf("invalid QC agents mode: %q", mode)
		}

		// Explicit mode requires explicit_list
		if mode == "explicit" && len(cfg.QualityControl.Agents.ExplicitList) == 0 {
			return fmt.Errorf("explicit mode requires non-empty explicit_list")
		}

		plan.QualityControl.Agents = models.QCAgentConfig{
			Mode:              mode,
			ExplicitList:      cfg.QualityControl.Agents.ExplicitList,
			AdditionalAgents:  cfg.QualityControl.Agents.Additional,
			BlockedAgents:     cfg.QualityControl.Agents.Blocked,
			MaxAgents:         cfg.QualityControl.Agents.MaxAgents,
			CacheTTLSeconds:   cfg.QualityControl.Agents.CacheTTLSeconds,
			RequireCodeReview: cfg.QualityControl.Agents.RequireCodeReview,
		}
	}

	// Parse worktree groups
	for _, yg := range cfg.WorktreeGroups {
		group := models.WorktreeGroup{
			GroupID:        yg.GroupID,
			Description:    yg.Description,
			ExecutionModel: yg.ExecutionModel,
			Isolation:      yg.Isolation,
			Rationale:      yg.Rationale,
		}
		plan.WorktreeGroups = append(plan.WorktreeGroups, group)
	}

	return nil
}

// buildPromptFromYAML constructs a comprehensive prompt from all YAML task sections
func buildPromptFromYAML(yt *yamlTask) string {
	var prompt strings.Builder

	// Task header
	taskNum, _ := convertToString(yt.TaskNumber)
	fmt.Fprintf(&prompt, "# Task %s: %s\n\n", taskNum, yt.Name)

	// Target files - CRITICAL: tells agent exactly which files to create/modify
	if len(yt.Files) > 0 {
		fmt.Fprintf(&prompt, "## Target Files (REQUIRED)\n\n")
		fmt.Fprintf(&prompt, "**You MUST create/modify these exact files:**\n")
		for _, file := range yt.Files {
			fmt.Fprintf(&prompt, "- `%s`\n", file)
		}
		fmt.Fprintf(&prompt, "\n⚠️ Do NOT create files with different names or paths. Use the exact paths listed above.\n\n")
	}

	// Description
	if yt.Description != "" {
		fmt.Fprintf(&prompt, "## Description\n\n%s\n\n", strings.TrimSpace(yt.Description))
	}

	// Test First section
	if yt.TestFirst.TestFile != "" || len(yt.TestFirst.Structure) > 0 ||
		yt.TestFirst.TestStructure != "" || yt.TestFirst.TestSpecifics != "" ||
		len(yt.TestFirst.Mocks) > 0 || len(yt.TestFirst.Fixtures) > 0 ||
		len(yt.TestFirst.Assertions) > 0 || len(yt.TestFirst.EdgeCases) > 0 ||
		yt.TestFirst.ExampleSkeleton != "" {
		fmt.Fprintf(&prompt, "## Test First (TDD)\n\n")

		if yt.TestFirst.TestFile != "" {
			fmt.Fprintf(&prompt, "**Test file**: `%s`\n\n", yt.TestFirst.TestFile)
		}

		// Handle both structure array and test_structure string
		if len(yt.TestFirst.Structure) > 0 {
			fmt.Fprintf(&prompt, "**Test structure**:\n")
			for _, item := range yt.TestFirst.Structure {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(item))
			}
			fmt.Fprintf(&prompt, "\n")
		} else if yt.TestFirst.TestStructure != "" {
			fmt.Fprintf(&prompt, "**Test structure**:\n%s\n\n", strings.TrimSpace(yt.TestFirst.TestStructure))
		}

		if len(yt.TestFirst.Mocks) > 0 {
			fmt.Fprintf(&prompt, "**Mocks**:\n")
			for _, mock := range yt.TestFirst.Mocks {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(mock))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.TestFirst.Fixtures) > 0 {
			fmt.Fprintf(&prompt, "**Fixtures**:\n")
			for _, fixture := range yt.TestFirst.Fixtures {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(fixture))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.TestFirst.Assertions) > 0 {
			fmt.Fprintf(&prompt, "**Assertions**:\n")
			for _, assertion := range yt.TestFirst.Assertions {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(assertion))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.TestFirst.EdgeCases) > 0 {
			fmt.Fprintf(&prompt, "**Edge cases**:\n")
			for _, edgeCase := range yt.TestFirst.EdgeCases {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(edgeCase))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if yt.TestFirst.TestSpecifics != "" {
			fmt.Fprintf(&prompt, "**Test specifics**:\n%s\n\n", strings.TrimSpace(yt.TestFirst.TestSpecifics))
		}

		if yt.TestFirst.ExampleSkeleton != "" {
			fmt.Fprintf(&prompt, "**Example test skeleton**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.TestFirst.ExampleSkeleton))
		}
	}

	// Implementation section
	hasImplementation := yt.Implementation.Approach != "" || yt.Implementation.CodeStructure != "" ||
		len(yt.Implementation.KeyPoints) > 0 ||
		len(yt.Implementation.Integration.Imports) > 0 ||
		len(yt.Implementation.Integration.ErrorHandling) > 0 ||
		len(yt.Implementation.IntegrationPoints) > 0

	if hasImplementation {
		fmt.Fprintf(&prompt, "## Implementation\n\n")

		if yt.Implementation.Approach != "" {
			fmt.Fprintf(&prompt, "**Approach**:\n%s\n\n", strings.TrimSpace(yt.Implementation.Approach))
		}

		if yt.Implementation.CodeStructure != "" {
			fmt.Fprintf(&prompt, "**Code structure**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.Implementation.CodeStructure))
		}

		// Handle key_points as array of objects
		if len(yt.Implementation.KeyPoints) > 0 {
			fmt.Fprintf(&prompt, "**Key points**:\n")
			for _, kp := range yt.Implementation.KeyPoints {
				if kp.Point != "" {
					fmt.Fprintf(&prompt, "- %s", strings.TrimSpace(kp.Point))
					if kp.Details != "" {
						fmt.Fprintf(&prompt, ": %s", strings.TrimSpace(kp.Details))
					}
					if kp.Reference != "" {
						fmt.Fprintf(&prompt, " (ref: %s)", strings.TrimSpace(kp.Reference))
					}
					fmt.Fprintf(&prompt, "\n")
				}
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Handle integration object
		hasIntegration := len(yt.Implementation.Integration.Imports) > 0 ||
			len(yt.Implementation.Integration.ServicesToInject) > 0 ||
			len(yt.Implementation.Integration.ConfigValues) > 0 ||
			len(yt.Implementation.Integration.ErrorHandling) > 0

		if hasIntegration {
			fmt.Fprintf(&prompt, "**Integration**:\n")

			if len(yt.Implementation.Integration.Imports) > 0 {
				fmt.Fprintf(&prompt, "- Imports: %s\n", strings.Join(yt.Implementation.Integration.Imports, ", "))
			}
			if len(yt.Implementation.Integration.ServicesToInject) > 0 {
				fmt.Fprintf(&prompt, "- Services to inject: %s\n", strings.Join(yt.Implementation.Integration.ServicesToInject, ", "))
			}
			if len(yt.Implementation.Integration.ConfigValues) > 0 {
				fmt.Fprintf(&prompt, "- Config values: %s\n", strings.Join(yt.Implementation.Integration.ConfigValues, ", "))
			}
			if len(yt.Implementation.Integration.ErrorHandling) > 0 {
				fmt.Fprintf(&prompt, "- Error handling:\n")
				for _, eh := range yt.Implementation.Integration.ErrorHandling {
					fmt.Fprintf(&prompt, "  - %s\n", strings.TrimSpace(eh))
				}
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Legacy integration_points field
		if len(yt.Implementation.IntegrationPoints) > 0 {
			fmt.Fprintf(&prompt, "**Integration points**:\n")
			for _, point := range yt.Implementation.IntegrationPoints {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(point))
			}
			fmt.Fprintf(&prompt, "\n")
		}
	}

	// Verification section
	hasVerification := len(yt.Verification.ManualTesting) > 0 ||
		yt.Verification.AutomatedTests.Command != "" ||
		len(yt.Verification.SuccessCriteria) > 0 ||
		yt.Verification.ExpectedOutput != ""

	if hasVerification {
		fmt.Fprintf(&prompt, "## Verification\n\n")

		// Handle manual_testing as array of objects
		if len(yt.Verification.ManualTesting) > 0 {
			fmt.Fprintf(&prompt, "**Manual testing**:\n")
			for i, mt := range yt.Verification.ManualTesting {
				if mt.Step != "" {
					fmt.Fprintf(&prompt, "%d. %s", i+1, strings.TrimSpace(mt.Step))
					if mt.Command != "" {
						fmt.Fprintf(&prompt, "\n   Command: `%s`", strings.TrimSpace(mt.Command))
					}
					if mt.Expected != "" {
						fmt.Fprintf(&prompt, "\n   Expected: %s", strings.TrimSpace(mt.Expected))
					}
					fmt.Fprintf(&prompt, "\n")
				}
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Handle automated_tests as object
		if yt.Verification.AutomatedTests.Command != "" {
			fmt.Fprintf(&prompt, "**Automated tests**:\n```bash\n%s\n```\n", strings.TrimSpace(yt.Verification.AutomatedTests.Command))
			if yt.Verification.AutomatedTests.ExpectedOutput != "" {
				fmt.Fprintf(&prompt, "\n**Expected output**:\n```\n%s\n```\n", strings.TrimSpace(yt.Verification.AutomatedTests.ExpectedOutput))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.Verification.SuccessCriteria) > 0 {
			fmt.Fprintf(&prompt, "**Success criteria**:\n")
			for _, criterion := range yt.Verification.SuccessCriteria {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(criterion))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Legacy expected_output field
		if yt.Verification.ExpectedOutput != "" && yt.Verification.AutomatedTests.ExpectedOutput == "" {
			fmt.Fprintf(&prompt, "**Expected output**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.Verification.ExpectedOutput))
		}
	}

	// Commit section
	if yt.Commit.Message != "" {
		fmt.Fprintf(&prompt, "## Commit\n\n")
		if yt.Commit.Type != "" {
			fmt.Fprintf(&prompt, "**Type**: %s\n", yt.Commit.Type)
		}
		fmt.Fprintf(&prompt, "**Message**: %s\n", strings.TrimSpace(yt.Commit.Message))
		if yt.Commit.Body != "" {
			fmt.Fprintf(&prompt, "\n**Body**:\n%s\n", strings.TrimSpace(yt.Commit.Body))
		}
		if len(yt.Commit.Files) > 0 {
			fmt.Fprintf(&prompt, "\n**Files**:\n")
			for _, file := range yt.Commit.Files {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(file))
			}
		}
		fmt.Fprintf(&prompt, "\n")
	}

	return prompt.String()
}

// parseTimeString parses time duration strings like "30m", "1h", "2h30m"
func parseTimeString(s string) (time.Duration, error) {
	// time.ParseDuration already handles formats like "30m", "1h", "2h30m"
	return time.ParseDuration(s)
}

// parseCompletionDate parses a date string in format "YYYY-MM-DD" and returns a time.Time
func parseCompletionDate(dateStr string) (time.Time, error) {
	return time.Parse("2006-01-02", dateStr)
}

// parseCompletionTimestamp parses a timestamp string in RFC3339 format and returns a time.Time
func parseCompletionTimestamp(timestampStr string) (time.Time, error) {
	return time.Parse(time.RFC3339, timestampStr)
}
