package parser

import (
	"fmt"
	"io"
	"strings"
	"time"

	"gopkg.in/yaml.v3"

	"github.com/harrison/conductor/internal/models"
)

// YAMLParser parses YAML format plans generated by /doc-yaml command
type YAMLParser struct{}

// yamlPlan represents the structure of a YAML plan file
type yamlPlan struct {
	Conductor *yamlConductorConfig `yaml:"conductor"`
	Plan      struct {
		Metadata struct {
			FeatureName    string `yaml:"feature_name"`
			Created        string `yaml:"created"`
			EstimatedTasks int    `yaml:"estimated_tasks"`
		} `yaml:"metadata"`
		Tasks []yamlTask `yaml:"tasks"`
	} `yaml:"plan"`
}

// yamlTask represents a single task in the YAML plan
type yamlTask struct {
	TaskNumber    int      `yaml:"task_number"`
	Name          string   `yaml:"name"`
	Files         []string `yaml:"files"`
	DependsOn     []int    `yaml:"depends_on"`
	EstimatedTime string   `yaml:"estimated_time"`
	Agent         string   `yaml:"agent"`
	Status        string   `yaml:"status"`
	Description   string   `yaml:"description"`
	TestFirst     struct {
		TestFile        string   `yaml:"test_file"`
		Structure       []string `yaml:"structure"`
		TestStructure   string   `yaml:"test_structure"`
		TestSpecifics   string   `yaml:"test_specifics"`
		Mocks           []string `yaml:"mocks"`
		Fixtures        []string `yaml:"fixtures"`
		Assertions      []string `yaml:"assertions"`
		EdgeCases       []string `yaml:"edge_cases"`
		ExampleSkeleton string   `yaml:"example_skeleton"`
	} `yaml:"test_first"`
	Implementation struct {
		Approach      string `yaml:"approach"`
		CodeStructure string `yaml:"code_structure"`
		KeyPoints     []struct {
			Point     string `yaml:"point"`
			Details   string `yaml:"details"`
			Reference string `yaml:"reference"`
		} `yaml:"key_points"`
		Integration struct {
			Imports           []string `yaml:"imports"`
			ServicesToInject  []string `yaml:"services_to_inject"`
			ConfigValues      []string `yaml:"config_values"`
			ErrorHandling     []string `yaml:"error_handling"`
		} `yaml:"integration"`
		IntegrationPoints []string `yaml:"integration_points"` // Legacy field
	} `yaml:"implementation"`
	Verification struct {
		ManualTesting []struct {
			Step     string `yaml:"step"`
			Command  string `yaml:"command"`
			Expected string `yaml:"expected"`
		} `yaml:"manual_testing"`
		AutomatedTests struct {
			Command        string `yaml:"command"`
			ExpectedOutput string `yaml:"expected_output"`
		} `yaml:"automated_tests"`
		SuccessCriteria []string `yaml:"success_criteria"`
		ExpectedOutput  string   `yaml:"expected_output"` // Legacy field
	} `yaml:"verification"`
	Commit struct {
		Type    string   `yaml:"type"`
		Message string   `yaml:"message"`
		Body    string   `yaml:"body"`
		Files   []string `yaml:"files"`
	} `yaml:"commit"`
}

// yamlConductorConfig represents the optional conductor configuration section in YAML
type yamlConductorConfig struct {
	DefaultAgent   string `yaml:"default_agent"`
	MaxConcurrency int    `yaml:"max_concurrency"`
	QualityControl struct {
		Enabled     bool   `yaml:"enabled"`
		ReviewAgent string `yaml:"review_agent"`
		RetryOnRed  int    `yaml:"retry_on_red"`
	} `yaml:"quality_control"`
}

// NewYAMLParser creates a new YAML parser instance
func NewYAMLParser() *YAMLParser {
	return &YAMLParser{}
}

// Parse parses a YAML plan from an io.Reader and returns a models.Plan
func (p *YAMLParser) Parse(r io.Reader) (*models.Plan, error) {
	var yp yamlPlan
	decoder := yaml.NewDecoder(r)
	if err := decoder.Decode(&yp); err != nil {
		return nil, fmt.Errorf("failed to decode YAML: %w", err)
	}

	plan := &models.Plan{
		Name: yp.Plan.Metadata.FeatureName,
	}

	// Parse conductor config if present
	if yp.Conductor != nil {
		if err := parseConductorConfigYAML(yp.Conductor, plan); err != nil {
			return nil, fmt.Errorf("failed to parse conductor config: %w", err)
		}
	}

	// Convert YAML tasks to models.Task
	for _, yt := range yp.Plan.Tasks {
		task := models.Task{
			Number:    yt.TaskNumber,
			Name:      yt.Name,
			Files:     yt.Files,
			DependsOn: yt.DependsOn,
			Agent:     yt.Agent,
		}

		// Parse estimated time
		if yt.EstimatedTime != "" {
			if dur, err := parseTimeString(yt.EstimatedTime); err == nil {
				task.EstimatedTime = dur
			}
		}

		// Build comprehensive prompt from all sections
		task.Prompt = buildPromptFromYAML(&yt)

		plan.Tasks = append(plan.Tasks, task)
	}

	return plan, nil
}

// parseConductorConfigYAML parses the conductor configuration section
func parseConductorConfigYAML(cfg *yamlConductorConfig, plan *models.Plan) error {
	plan.DefaultAgent = cfg.DefaultAgent

	plan.QualityControl = models.QualityControlConfig{
		Enabled:     cfg.QualityControl.Enabled,
		ReviewAgent: cfg.QualityControl.ReviewAgent,
		RetryOnRed:  cfg.QualityControl.RetryOnRed,
	}

	return nil
}

// buildPromptFromYAML constructs a comprehensive prompt from all YAML task sections
func buildPromptFromYAML(yt *yamlTask) string {
	var prompt strings.Builder

	// Task header
	fmt.Fprintf(&prompt, "# Task %d: %s\n\n", yt.TaskNumber, yt.Name)

	// Description
	if yt.Description != "" {
		fmt.Fprintf(&prompt, "## Description\n\n%s\n\n", strings.TrimSpace(yt.Description))
	}

	// Test First section
	if yt.TestFirst.TestFile != "" || len(yt.TestFirst.Structure) > 0 ||
		yt.TestFirst.TestStructure != "" || yt.TestFirst.TestSpecifics != "" ||
		len(yt.TestFirst.Mocks) > 0 || len(yt.TestFirst.Fixtures) > 0 ||
		len(yt.TestFirst.Assertions) > 0 || len(yt.TestFirst.EdgeCases) > 0 ||
		yt.TestFirst.ExampleSkeleton != "" {
		fmt.Fprintf(&prompt, "## Test First (TDD)\n\n")

		if yt.TestFirst.TestFile != "" {
			fmt.Fprintf(&prompt, "**Test file**: `%s`\n\n", yt.TestFirst.TestFile)
		}

		// Handle both structure array and test_structure string
		if len(yt.TestFirst.Structure) > 0 {
			fmt.Fprintf(&prompt, "**Test structure**:\n")
			for _, item := range yt.TestFirst.Structure {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(item))
			}
			fmt.Fprintf(&prompt, "\n")
		} else if yt.TestFirst.TestStructure != "" {
			fmt.Fprintf(&prompt, "**Test structure**:\n%s\n\n", strings.TrimSpace(yt.TestFirst.TestStructure))
		}

		if len(yt.TestFirst.Mocks) > 0 {
			fmt.Fprintf(&prompt, "**Mocks**:\n")
			for _, mock := range yt.TestFirst.Mocks {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(mock))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.TestFirst.Fixtures) > 0 {
			fmt.Fprintf(&prompt, "**Fixtures**:\n")
			for _, fixture := range yt.TestFirst.Fixtures {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(fixture))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.TestFirst.Assertions) > 0 {
			fmt.Fprintf(&prompt, "**Assertions**:\n")
			for _, assertion := range yt.TestFirst.Assertions {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(assertion))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.TestFirst.EdgeCases) > 0 {
			fmt.Fprintf(&prompt, "**Edge cases**:\n")
			for _, edgeCase := range yt.TestFirst.EdgeCases {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(edgeCase))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if yt.TestFirst.TestSpecifics != "" {
			fmt.Fprintf(&prompt, "**Test specifics**:\n%s\n\n", strings.TrimSpace(yt.TestFirst.TestSpecifics))
		}

		if yt.TestFirst.ExampleSkeleton != "" {
			fmt.Fprintf(&prompt, "**Example test skeleton**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.TestFirst.ExampleSkeleton))
		}
	}

	// Implementation section
	hasImplementation := yt.Implementation.Approach != "" || yt.Implementation.CodeStructure != "" ||
		len(yt.Implementation.KeyPoints) > 0 ||
		len(yt.Implementation.Integration.Imports) > 0 ||
		len(yt.Implementation.Integration.ErrorHandling) > 0 ||
		len(yt.Implementation.IntegrationPoints) > 0

	if hasImplementation {
		fmt.Fprintf(&prompt, "## Implementation\n\n")

		if yt.Implementation.Approach != "" {
			fmt.Fprintf(&prompt, "**Approach**:\n%s\n\n", strings.TrimSpace(yt.Implementation.Approach))
		}

		if yt.Implementation.CodeStructure != "" {
			fmt.Fprintf(&prompt, "**Code structure**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.Implementation.CodeStructure))
		}

		// Handle key_points as array of objects
		if len(yt.Implementation.KeyPoints) > 0 {
			fmt.Fprintf(&prompt, "**Key points**:\n")
			for _, kp := range yt.Implementation.KeyPoints {
				if kp.Point != "" {
					fmt.Fprintf(&prompt, "- %s", strings.TrimSpace(kp.Point))
					if kp.Details != "" {
						fmt.Fprintf(&prompt, ": %s", strings.TrimSpace(kp.Details))
					}
					if kp.Reference != "" {
						fmt.Fprintf(&prompt, " (ref: %s)", strings.TrimSpace(kp.Reference))
					}
					fmt.Fprintf(&prompt, "\n")
				}
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Handle integration object
		hasIntegration := len(yt.Implementation.Integration.Imports) > 0 ||
			len(yt.Implementation.Integration.ServicesToInject) > 0 ||
			len(yt.Implementation.Integration.ConfigValues) > 0 ||
			len(yt.Implementation.Integration.ErrorHandling) > 0

		if hasIntegration {
			fmt.Fprintf(&prompt, "**Integration**:\n")

			if len(yt.Implementation.Integration.Imports) > 0 {
				fmt.Fprintf(&prompt, "- Imports: %s\n", strings.Join(yt.Implementation.Integration.Imports, ", "))
			}
			if len(yt.Implementation.Integration.ServicesToInject) > 0 {
				fmt.Fprintf(&prompt, "- Services to inject: %s\n", strings.Join(yt.Implementation.Integration.ServicesToInject, ", "))
			}
			if len(yt.Implementation.Integration.ConfigValues) > 0 {
				fmt.Fprintf(&prompt, "- Config values: %s\n", strings.Join(yt.Implementation.Integration.ConfigValues, ", "))
			}
			if len(yt.Implementation.Integration.ErrorHandling) > 0 {
				fmt.Fprintf(&prompt, "- Error handling:\n")
				for _, eh := range yt.Implementation.Integration.ErrorHandling {
					fmt.Fprintf(&prompt, "  - %s\n", strings.TrimSpace(eh))
				}
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Legacy integration_points field
		if len(yt.Implementation.IntegrationPoints) > 0 {
			fmt.Fprintf(&prompt, "**Integration points**:\n")
			for _, point := range yt.Implementation.IntegrationPoints {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(point))
			}
			fmt.Fprintf(&prompt, "\n")
		}
	}

	// Verification section
	hasVerification := len(yt.Verification.ManualTesting) > 0 ||
		yt.Verification.AutomatedTests.Command != "" ||
		len(yt.Verification.SuccessCriteria) > 0 ||
		yt.Verification.ExpectedOutput != ""

	if hasVerification {
		fmt.Fprintf(&prompt, "## Verification\n\n")

		// Handle manual_testing as array of objects
		if len(yt.Verification.ManualTesting) > 0 {
			fmt.Fprintf(&prompt, "**Manual testing**:\n")
			for i, mt := range yt.Verification.ManualTesting {
				if mt.Step != "" {
					fmt.Fprintf(&prompt, "%d. %s", i+1, strings.TrimSpace(mt.Step))
					if mt.Command != "" {
						fmt.Fprintf(&prompt, "\n   Command: `%s`", strings.TrimSpace(mt.Command))
					}
					if mt.Expected != "" {
						fmt.Fprintf(&prompt, "\n   Expected: %s", strings.TrimSpace(mt.Expected))
					}
					fmt.Fprintf(&prompt, "\n")
				}
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Handle automated_tests as object
		if yt.Verification.AutomatedTests.Command != "" {
			fmt.Fprintf(&prompt, "**Automated tests**:\n```bash\n%s\n```\n", strings.TrimSpace(yt.Verification.AutomatedTests.Command))
			if yt.Verification.AutomatedTests.ExpectedOutput != "" {
				fmt.Fprintf(&prompt, "\n**Expected output**:\n```\n%s\n```\n", strings.TrimSpace(yt.Verification.AutomatedTests.ExpectedOutput))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.Verification.SuccessCriteria) > 0 {
			fmt.Fprintf(&prompt, "**Success criteria**:\n")
			for _, criterion := range yt.Verification.SuccessCriteria {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(criterion))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		// Legacy expected_output field
		if yt.Verification.ExpectedOutput != "" && yt.Verification.AutomatedTests.ExpectedOutput == "" {
			fmt.Fprintf(&prompt, "**Expected output**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.Verification.ExpectedOutput))
		}
	}

	// Commit section
	if yt.Commit.Message != "" {
		fmt.Fprintf(&prompt, "## Commit\n\n")
		if yt.Commit.Type != "" {
			fmt.Fprintf(&prompt, "**Type**: %s\n", yt.Commit.Type)
		}
		fmt.Fprintf(&prompt, "**Message**: %s\n", strings.TrimSpace(yt.Commit.Message))
		if yt.Commit.Body != "" {
			fmt.Fprintf(&prompt, "\n**Body**:\n%s\n", strings.TrimSpace(yt.Commit.Body))
		}
		if len(yt.Commit.Files) > 0 {
			fmt.Fprintf(&prompt, "\n**Files**:\n")
			for _, file := range yt.Commit.Files {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(file))
			}
		}
		fmt.Fprintf(&prompt, "\n")
	}

	return prompt.String()
}

// parseTimeString parses time duration strings like "30m", "1h", "2h30m"
func parseTimeString(s string) (time.Duration, error) {
	// time.ParseDuration already handles formats like "30m", "1h", "2h30m"
	return time.ParseDuration(s)
}
