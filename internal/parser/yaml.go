package parser

import (
	"fmt"
	"io"
	"strings"
	"time"

	"gopkg.in/yaml.v3"

	"github.com/harrison/conductor/internal/models"
)

// YAMLParser parses YAML format plans generated by /doc-yaml command
type YAMLParser struct{}

// yamlPlan represents the structure of a YAML plan file
type yamlPlan struct {
	Conductor *yamlConductorConfig `yaml:"conductor"`
	Plan      struct {
		Metadata struct {
			FeatureName    string `yaml:"feature_name"`
			Created        string `yaml:"created"`
			EstimatedTasks int    `yaml:"estimated_tasks"`
		} `yaml:"metadata"`
		Tasks []yamlTask `yaml:"tasks"`
	} `yaml:"plan"`
}

// yamlTask represents a single task in the YAML plan
type yamlTask struct {
	TaskNumber    int      `yaml:"task_number"`
	Name          string   `yaml:"name"`
	Files         []string `yaml:"files"`
	DependsOn     []int    `yaml:"depends_on"`
	EstimatedTime string   `yaml:"estimated_time"`
	Agent         string   `yaml:"agent"`
	Description   string   `yaml:"description"`
	TestFirst     struct {
		TestFile        string `yaml:"test_file"`
		TestStructure   string `yaml:"test_structure"`
		TestSpecifics   string `yaml:"test_specifics"`
		ExampleSkeleton string `yaml:"example_skeleton"`
	} `yaml:"test_first"`
	Implementation struct {
		Approach           string   `yaml:"approach"`
		CodeStructure      string   `yaml:"code_structure"`
		KeyPoints          []string `yaml:"key_points"`
		IntegrationPoints  []string `yaml:"integration_points"`
	} `yaml:"implementation"`
	Verification struct {
		ManualTesting   []string `yaml:"manual_testing"`
		AutomatedTests  string   `yaml:"automated_tests"`
		ExpectedOutput  string   `yaml:"expected_output"`
	} `yaml:"verification"`
}

// yamlConductorConfig represents the optional conductor configuration section in YAML
type yamlConductorConfig struct {
	DefaultAgent   string `yaml:"default_agent"`
	MaxConcurrency int    `yaml:"max_concurrency"`
	QualityControl struct {
		Enabled     bool   `yaml:"enabled"`
		ReviewAgent string `yaml:"review_agent"`
		RetryOnRed  int    `yaml:"retry_on_red"`
	} `yaml:"quality_control"`
}

// NewYAMLParser creates a new YAML parser instance
func NewYAMLParser() *YAMLParser {
	return &YAMLParser{}
}

// Parse parses a YAML plan from an io.Reader and returns a models.Plan
func (p *YAMLParser) Parse(r io.Reader) (*models.Plan, error) {
	var yp yamlPlan
	decoder := yaml.NewDecoder(r)
	if err := decoder.Decode(&yp); err != nil {
		return nil, fmt.Errorf("failed to decode YAML: %w", err)
	}

	plan := &models.Plan{
		Name: yp.Plan.Metadata.FeatureName,
	}

	// Parse conductor config if present
	if yp.Conductor != nil {
		if err := parseConductorConfigYAML(yp.Conductor, plan); err != nil {
			return nil, fmt.Errorf("failed to parse conductor config: %w", err)
		}
	}

	// Convert YAML tasks to models.Task
	for _, yt := range yp.Plan.Tasks {
		task := models.Task{
			Number:    yt.TaskNumber,
			Name:      yt.Name,
			Files:     yt.Files,
			DependsOn: yt.DependsOn,
			Agent:     yt.Agent,
		}

		// Parse estimated time
		if yt.EstimatedTime != "" {
			if dur, err := parseTimeString(yt.EstimatedTime); err == nil {
				task.EstimatedTime = dur
			}
		}

		// Build comprehensive prompt from all sections
		task.Prompt = buildPromptFromYAML(&yt)

		plan.Tasks = append(plan.Tasks, task)
	}

	return plan, nil
}

// parseConductorConfigYAML parses the conductor configuration section
func parseConductorConfigYAML(cfg *yamlConductorConfig, plan *models.Plan) error {
	plan.DefaultAgent = cfg.DefaultAgent

	plan.QualityControl = models.QualityControlConfig{
		Enabled:     cfg.QualityControl.Enabled,
		ReviewAgent: cfg.QualityControl.ReviewAgent,
		RetryOnRed:  cfg.QualityControl.RetryOnRed,
	}

	return nil
}

// buildPromptFromYAML constructs a comprehensive prompt from all YAML task sections
func buildPromptFromYAML(yt *yamlTask) string {
	var prompt strings.Builder

	// Task header
	fmt.Fprintf(&prompt, "# Task %d: %s\n\n", yt.TaskNumber, yt.Name)

	// Description
	if yt.Description != "" {
		fmt.Fprintf(&prompt, "## Description\n\n%s\n\n", strings.TrimSpace(yt.Description))
	}

	// Test First section
	if yt.TestFirst.TestFile != "" || yt.TestFirst.TestStructure != "" ||
	   yt.TestFirst.TestSpecifics != "" || yt.TestFirst.ExampleSkeleton != "" {
		fmt.Fprintf(&prompt, "## Test First (TDD)\n\n")

		if yt.TestFirst.TestFile != "" {
			fmt.Fprintf(&prompt, "**Test file**: `%s`\n\n", yt.TestFirst.TestFile)
		}

		if yt.TestFirst.TestStructure != "" {
			fmt.Fprintf(&prompt, "**Test structure**:\n%s\n\n", strings.TrimSpace(yt.TestFirst.TestStructure))
		}

		if yt.TestFirst.TestSpecifics != "" {
			fmt.Fprintf(&prompt, "**Test specifics**:\n%s\n\n", strings.TrimSpace(yt.TestFirst.TestSpecifics))
		}

		if yt.TestFirst.ExampleSkeleton != "" {
			fmt.Fprintf(&prompt, "**Example test skeleton**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.TestFirst.ExampleSkeleton))
		}
	}

	// Implementation section
	if yt.Implementation.Approach != "" || yt.Implementation.CodeStructure != "" ||
	   len(yt.Implementation.KeyPoints) > 0 || len(yt.Implementation.IntegrationPoints) > 0 {
		fmt.Fprintf(&prompt, "## Implementation\n\n")

		if yt.Implementation.Approach != "" {
			fmt.Fprintf(&prompt, "**Approach**:\n%s\n\n", strings.TrimSpace(yt.Implementation.Approach))
		}

		if yt.Implementation.CodeStructure != "" {
			fmt.Fprintf(&prompt, "**Code structure**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.Implementation.CodeStructure))
		}

		if len(yt.Implementation.KeyPoints) > 0 {
			fmt.Fprintf(&prompt, "**Key points**:\n")
			for _, point := range yt.Implementation.KeyPoints {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(point))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if len(yt.Implementation.IntegrationPoints) > 0 {
			fmt.Fprintf(&prompt, "**Integration points**:\n")
			for _, point := range yt.Implementation.IntegrationPoints {
				fmt.Fprintf(&prompt, "- %s\n", strings.TrimSpace(point))
			}
			fmt.Fprintf(&prompt, "\n")
		}
	}

	// Verification section
	if len(yt.Verification.ManualTesting) > 0 || yt.Verification.AutomatedTests != "" ||
	   yt.Verification.ExpectedOutput != "" {
		fmt.Fprintf(&prompt, "## Verification\n\n")

		if len(yt.Verification.ManualTesting) > 0 {
			fmt.Fprintf(&prompt, "**Manual testing**:\n")
			for i, step := range yt.Verification.ManualTesting {
				fmt.Fprintf(&prompt, "%d. %s\n", i+1, strings.TrimSpace(step))
			}
			fmt.Fprintf(&prompt, "\n")
		}

		if yt.Verification.AutomatedTests != "" {
			fmt.Fprintf(&prompt, "**Automated tests**:\n```bash\n%s\n```\n\n", strings.TrimSpace(yt.Verification.AutomatedTests))
		}

		if yt.Verification.ExpectedOutput != "" {
			fmt.Fprintf(&prompt, "**Expected output**:\n```\n%s\n```\n\n", strings.TrimSpace(yt.Verification.ExpectedOutput))
		}
	}

	return prompt.String()
}

// parseTimeString parses time duration strings like "30m", "1h", "2h30m"
func parseTimeString(s string) (time.Duration, error) {
	// time.ParseDuration already handles formats like "30m", "1h", "2h30m"
	return time.ParseDuration(s)
}
