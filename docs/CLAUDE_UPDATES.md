# CLAUDE.md Updates: Cross-File Dependencies (v2.5)

This document shows the updates needed for CLAUDE.md to document cross-file dependency support.

## Section 1: Dependency Graph Algorithm Updates

### ORIGINAL (Line 176-189)

```markdown
### Dependency Graph Algorithm

Uses **Kahn's algorithm** for topological sort with wave grouping:
1. Calculate in-degree for each task (number of dependencies)
2. Wave 1: All tasks with in-degree 0 (no dependencies)
3. Process wave, decrease in-degree of dependent tasks
4. Wave N: Tasks that now have in-degree 0
5. Repeat until all tasks processed

Cycle detection uses **DFS with color marking**:
- White (0): Not visited
- Gray (1): Currently visiting (on recursion stack)
- Black (2): Fully visited
- Back edge (gray → gray) = cycle detected
```

### UPDATED

```markdown
### Dependency Graph Algorithm

Uses **Kahn's algorithm** for topological sort with wave grouping:
1. Calculate in-degree for each task (number of dependencies)
2. Resolve cross-file dependencies to unified task identifiers
3. Wave 1: All tasks with in-degree 0 (no dependencies)
4. Process wave, decrease in-degree of dependent tasks
5. Wave N: Tasks that now have in-degree 0
6. Repeat until all tasks processed

**Cross-File Dependency Resolution (v2.5+):**
- Tasks can reference other files: `file: foundation.yaml`, `task: 1`
- Plan merger converts cross-file references to unified task IDs
- Example: `foundation.yaml#1` → internal task ID for dependency calculation
- Validation ensures all cross-file references exist before graph building

**Cycle Detection uses DFS with color marking:**
- White (0): Not visited
- Gray (1): Currently visiting (on recursion stack)
- Black (2): Fully visited
- Back edge (gray → gray) = cycle detected
- Detects both intra-file and cross-file circular dependencies

**Example Dependency Graph:**
```
foundation.yaml#1 (Database Setup)
  ↓
foundation.yaml#2 (Cache Setup)
  ↓
services.yaml#1 (Auth Service) + services.yaml#2 (API Service)
  ↓
integration.yaml#1 (Wire Components)
```
```

---

## Section 2: Task Metadata Parsing Updates

### ORIGINAL (Line 499-527)

```markdown
### Task Metadata Parsing

Conductor's parsers (Markdown and YAML) extract these fields from plan files:

**Core fields** (always parsed):
- `Number` - Task identifier (string)
- `Name` - Task title
- `Files` - List of files the task modifies
- `DependsOn` - Task dependencies for wave calculation
- `EstimatedTime` - Duration estimate (parsed as time.Duration)
- `Agent` - Claude agent to execute the task
- `Status` - Task completion status (completed, failed, in-progress, pending)
- `CompletedAt` - Timestamp when task was completed
- `SuccessCriteria` - List of explicit success criteria for QC verification (v2.3+)
- `TestCommands` - Commands to run for verification (v2.3+)

**Multi-file plan fields**:
- `WorktreeGroup` - Group assignment for task organization
  - Parsed by both Markdown parser (`**WorktreeGroup**: value`) and YAML parser (`worktree_group: value`)
  - Stored in Task.WorktreeGroup field
  - Used for organizational purposes and multi-file plan coordination
  - **Not used for execution control** - conductor doesn't enforce isolation or execution order based on groups
  - Groups are tracked in Wave.GroupInfo for logging and analysis

**Extended task sections** (for human developers):
- `test_first`, `implementation`, `verification`, `commit` sections in YAML
- These sections are included in Task.Prompt as markdown but not parsed as structured fields
- Provide detailed guidance for engineers implementing the tasks
- Generated by `/doc` and `/doc-yaml` commands for comprehensive task specifications
```

### UPDATED

```markdown
### Task Metadata Parsing

Conductor's parsers (Markdown and YAML) extract these fields from plan files:

**Core fields** (always parsed):
- `Number` - Task identifier (string)
- `Name` - Task title
- `Files` - List of files the task modifies
- `DependsOn` - Task dependencies for wave calculation (local or cross-file, v2.5+)
- `EstimatedTime` - Duration estimate (parsed as time.Duration)
- `Agent` - Claude agent to execute the task
- `Status` - Task completion status (completed, failed, in-progress, pending)
- `CompletedAt` - Timestamp when task was completed
- `SuccessCriteria` - List of explicit success criteria for QC verification (v2.3+)
- `TestCommands` - Commands to run for verification (v2.3+)

**Dependency Notation (v2.5+):**

Local dependencies (same file):
```yaml
depends_on: [1, 2, 3]
```

Cross-file dependencies (different file):
```yaml
depends_on:
  - file: foundation.yaml
    task: 1
  - file: services/auth.yaml
    task: 2
```

Mixed dependencies (both local and cross-file):
```yaml
depends_on:
  - 1                    # Local reference
  - file: foundation.yaml
    task: 2              # Cross-file reference
```

**How Dependencies Are Resolved:**
- Local references (`1, 2, 3`) resolved within the file
- Cross-file references (`file: X.yaml, task: Y`) resolved during plan merging
- All resolved to unified task identifiers for dependency graph
- Validation ensures all referenced files and tasks exist

**Multi-file plan fields**:
- `WorktreeGroup` - Group assignment for task organization
  - Parsed by both Markdown parser (`**WorktreeGroup**: value`) and YAML parser (`worktree_group: value`)
  - Stored in Task.WorktreeGroup field
  - Used for organizational purposes and multi-file plan coordination
  - **Not used for execution control** - conductor doesn't enforce isolation or execution order based on groups
  - Groups are tracked in Wave.GroupInfo for logging and analysis

**Extended task sections** (for human developers):
- `test_first`, `implementation`, `verification`, `commit` sections in YAML
- These sections are included in Task.Prompt as markdown but not parsed as structured fields
- Provide detailed guidance for engineers implementing the tasks
- Generated by `/doc` and `/doc-yaml` commands for comprehensive task specifications
```

---

## Section 3: Multi-File Plans Section (Expanded)

### ORIGINAL (Line 840-857)

```markdown
## Multi-File Plan Examples

### Example 1: Split Backend Plan

Part 1 (setup.md):
```markdown
## Task 1: Database Setup
**Files**: infrastructure/db.tf
**Depends on**: None

Initialize PostgreSQL and migrations.

## Task 2: API Server Setup
**Files**: cmd/api/main.go
**Depends on**: Task 1
**WorktreeGroup**: backend-core

Set up web server framework.
```

Part 2 (features.md):
```markdown
## Task 3: Auth Service
**Files**: internal/auth/auth.go
**Depends on**: Task 1, Task 2
**WorktreeGroup**: backend-features

Implement JWT authentication.

## Task 4: User API
**Files**: internal/api/users.go
**Depends on**: Task 3
**WorktreeGroup**: backend-features

Create user CRUD endpoints.
```

Execute together:
```bash
conductor run setup.md features.md --max-concurrency 3
```

Or validate first:
```bash
conductor validate setup.md features.md
```

### Example 2: Microservices Plan

Three separate plans:
- `auth-service-plan.md` - Authentication service (6 tasks)
- `api-service-plan.md` - Main API (8 tasks)
- `deployment-plan.md` - Infrastructure & deployment (5 tasks)

With worktree groups:
- `auth-service` group → sequential execution (isolation: strong)
- `api-service` group → parallel where possible (isolation: weak)
- `deployment` group → sequential (isolation: strong)
```

### UPDATED

```markdown
## Multi-File Plan Examples

### Example 1: Split Backend Plan with Explicit Dependencies (v2.5+)

**Recommended Approach:** Use explicit cross-file dependencies for clarity

Part 1 (setup.yaml):
```yaml
plan:
  name: Backend Setup
  tasks:
    - id: 1
      name: Database Setup
      files: [infrastructure/db.tf]
      depends_on: []

    - id: 2
      name: API Server Setup
      files: [cmd/api/main.go]
      depends_on: [1]
      worktree_group: backend-core
```

Part 2 (features.yaml):
```yaml
plan:
  name: Backend Features
  tasks:
    - id: 3
      name: Auth Service
      files: [internal/auth/auth.go]
      depends_on:
        - file: setup.yaml
          task: 1
        - file: setup.yaml
          task: 2
      worktree_group: backend-features

    - id: 4
      name: User API
      files: [internal/api/users.go]
      depends_on:
        - 3  # Local dependency (same file)
      worktree_group: backend-features
```

Execute together (order-independent with explicit dependencies):
```bash
conductor run setup.yaml features.yaml --max-concurrency 3
# Or in any order - dependencies are explicit:
conductor run features.yaml setup.yaml --max-concurrency 3
```

Validate first:
```bash
conductor validate setup.yaml features.yaml
# Shows clear error if cross-file references are broken
```

### Example 1b: Split Backend Plan (Implicit, v2.4 Backward Compatible)

For simpler plans without explicit cross-file dependencies:

Part 1 (setup.md):
```markdown
## Task 1: Database Setup
**Files**: infrastructure/db.tf
**Depends on**: None

Initialize PostgreSQL and migrations.

## Task 2: API Server Setup
**Files**: cmd/api/main.go
**Depends on**: Task 1
**WorktreeGroup**: backend-core

Set up web server framework.
```

Part 2 (features.md):
```markdown
## Task 3: Auth Service
**Files**: internal/auth/auth.go
**Depends on**: None

Implement JWT authentication.
(Will execute after all setup.md tasks due to file order)

## Task 4: User API
**Files**: internal/api/users.go
**Depends on**: Task 3
**WorktreeGroup**: backend-features

Create user CRUD endpoints.
```

Execute together:
```bash
conductor run setup.md features.md --max-concurrency 3
```

**Note:** This implicit approach still works (v2.4 compatible) but the explicit approach above is recommended for new plans.

### Example 2: Microservices Plan with Cross-File Dependencies

Three separate plans with explicit dependencies:

**infrastructure.yaml** - Core infrastructure (no external dependencies)
```yaml
plan:
  name: Infrastructure
  tasks:
    - id: 1
      name: Database Setup
      depends_on: []

    - id: 2
      name: Redis Setup
      depends_on: [1]
```

**auth-service.yaml** - Auth service (depends on infrastructure)
```yaml
plan:
  name: Auth Service
  tasks:
    - id: 3
      name: Auth Module
      depends_on:
        - file: infrastructure.yaml
          task: 1  # Uses database from infrastructure
      worktree_group: auth-service
```

**api-service.yaml** - API service (depends on infrastructure and auth)
```yaml
plan:
  name: API Service
  tasks:
    - id: 4
      name: API Router
      depends_on:
        - file: infrastructure.yaml
          task: 2  # Uses Redis from infrastructure
      worktree_group: api-service

    - id: 5
      name: Integrate Auth
      depends_on:
        - 4  # Depends on API router
        - file: auth-service.yaml
          task: 3  # Uses auth module
      worktree_group: api-service
```

**deployment.yaml** - Deployment (depends on all services)
```yaml
plan:
  name: Deployment
  tasks:
    - id: 6
      name: Deploy All Services
      depends_on:
        - file: api-service.yaml
          task: 5  # API must be ready
        - file: auth-service.yaml
          task: 3  # Auth must be ready
      worktree_group: deployment
```

Execute all together (dependencies control order):
```bash
conductor run infrastructure.yaml auth-service.yaml api-service.yaml deployment.yaml --max-concurrency 4
```

Validate before execution:
```bash
conductor validate infrastructure.yaml auth-service.yaml api-service.yaml deployment.yaml
```

**Benefits of explicit cross-file dependencies:**
- Dependencies are self-documenting
- Works in any file order
- Clear error messages if files or tasks are missing
- Resumable execution tracks correctly across files
- Scales to complex systems with many services

### Example 3: Implicit Multi-File Ordering (v2.4, still supported)

If you prefer simpler file organization without explicit cross-file dependencies:

Three separate plans:
- `auth-service-plan.md` - Authentication service (6 tasks)
- `api-service-plan.md` - Main API (8 tasks)
- `deployment-plan.md` - Infrastructure & deployment (5 tasks)

With worktree groups:
- `auth-service` group → sequential execution (isolation: strong)
- `api-service` group → parallel where possible (isolation: weak)
- `deployment` group → sequential (isolation: strong)

Execute in specific order:
```bash
conductor run auth-service-plan.md api-service-plan.md deployment-plan.md
```

**Note:** This approach is fully backward compatible but provides less explicit dependency documentation.

### Migration Path

**To migrate from implicit to explicit dependencies:**
1. Convert task dependencies to include `file:` and `task:` fields
2. Validate: `conductor validate *.yaml`
3. No breaking changes - both formats work together

See [Migration Guide](./MIGRATION_CROSS_FILE_DEPS.md) for detailed step-by-step instructions.
```

---

## Section 4: Multi-File Plan Best Practices Updates

### ORIGINAL (Line 931-957)

```markdown
### Multi-File Plans

**File Organization**
- 1 file per feature/module/service
- Aim for 5-20 tasks per file
- Clear, descriptive filenames

**Cross-File Dependencies**
- Keep intra-file dependencies tight
- Minimize cross-file dependencies where possible
- Document file execution order if strict

**Worktree Groups**
- Use groups for execution control
- `sequential` for state-dependent tasks
- `parallel` for independent tasks
- `strong` isolation for infrastructure tasks

**Task Naming**
- Prefix with module name: "Backend: Setup DB"
- Clear task boundaries
- File mappings should be obvious

**Testing Split Plans**
- Validate all files together: `conductor validate *.md`
- Dry-run before actual execution
- Check dependency graph for cross-file links
```

### UPDATED

```markdown
### Multi-File Plans

**File Organization**
- 1 file per feature/module/service
- Aim for 5-20 tasks per file
- Clear, descriptive filenames
- Related files in subdirectories (e.g., `services/auth.yaml`)

**Dependency Declaration (v2.5+)**
- Use explicit cross-file references for clarity: `file: foundation.yaml`, `task: 1`
- Or rely on implicit file ordering (backward compatible)
- Recommended: explicit for plans with 3+ files or complex dependencies
- Recommended: implicit for simple 2-file plans

**Local Dependencies:**
```yaml
depends_on: [1, 2, 3]  # Reference local tasks by number
```

**Cross-File Dependencies:**
```yaml
depends_on:
  - file: foundation.yaml
    task: 1
  - file: services/auth.yaml
    task: 2
```

**Cross-File Dependency Guidelines:**
- Keep intra-file dependencies tight
- Minimize cross-file dependencies (aim for 1-3 per file)
- Use explicit notation for clarity in complex plans
- Document why each cross-file dependency exists (add comments)
- Validate all cross-file references: `conductor validate *.yaml`

**Worktree Groups**
- Use groups for logical organization
- `sequential` for state-dependent tasks
- `parallel` for independent tasks
- `strong` isolation for infrastructure tasks
- Note: Groups are organizational only; dependencies control execution order

**Task Naming**
- Prefix with module name: "Backend: Setup DB", "Auth: Initialize"
- Clear task boundaries
- File mappings should be obvious
- Document integration points for tasks with dependencies

**Testing Split Plans**
- Validate all files together: `conductor validate *.yaml`
- Verify cross-file references: `conductor validate --verbose`
- Dry-run before actual execution: `conductor run *.yaml --dry-run`
- Check dependency graph includes cross-file links
- Test resume functionality: `conductor run *.yaml --skip-completed`

**Common Patterns:**
- **Linear chain:** foundation.yaml → services.yaml → integration.yaml
- **Star dependency:** foundation.yaml ← [auth.yaml, api.yaml, data.yaml]
- **Complex web:** Multiple services with multiple cross-file dependencies
- See [Cross-File Dependencies Reference](./CROSS_FILE_DEPENDENCIES.md) for detailed patterns

**Migration Guide:**
For plans that already use implicit file ordering, see [Migration Guide](./MIGRATION_CROSS_FILE_DEPS.md) for gradual adoption of explicit cross-file dependencies.
```

---

## Section 5: New Production Status Update

### UPDATED STATUS (Replace line 9, Project Overview)

**Before:**
```
**Current Status**: Production-ready v2.4.0 with comprehensive multi-agent orchestration, multi-file plan support, quality control reviews, adaptive learning system, inter-retry agent swapping, structured success criteria with per-criterion verification, intelligent QC agent selection with critical RED verdict fix, domain-specific review criteria, and auto-incrementing version management.
```

**After:**
```
**Current Status**: Production-ready v2.5.0 with comprehensive multi-agent orchestration, explicit cross-file dependencies, multi-file plan support, quality control reviews, adaptive learning system, inter-retry agent swapping, structured success criteria with per-criterion verification, intelligent QC agent selection with critical RED verdict fix, integration tasks with dual criteria, domain-specific review criteria, and auto-incrementing version management.
```

---

## Section 6: Add to High-Level Flow Section

### INSERT after line 122 (after Multi-File Plans flow)

```markdown
**Cross-File Dependency Resolution (v2.5+):**
```
Multiple Plan Files (.md/.yaml)
  → Multi-File Loader (auto-detects format per file)
  → Cross-File Reference Validator (checks file/task existence)
  → Plan Merger (resolves cross-file references, deduplicates, merges)
  → Unified Task Graph (all tasks with resolved dependencies)
  → Dependency Graph Builder (cross-file dependencies)
  → Wave Calculator (respects worktree groups)
  → [Rest of pipeline as above]
```

**Cross-file reference examples:**
- YAML: `file: foundation.yaml, task: 1`
- Resolved to: unified task identifier for dependency calculation
- Validation: ensures file and task exist before processing
```

---

## Integration Points

These updates should be made in this order:

1. **Update Project Overview** (line 9) - Latest version status
2. **Update High-Level Flow** (after line 122) - Add cross-file flow
3. **Update Dependency Graph Algorithm** (line 176) - Explain cross-file resolution
4. **Update Task Metadata Parsing** (line 499) - Document cross-file syntax
5. **Expand Multi-File Plan Examples** (line 840) - Add explicit dependency examples
6. **Expand Multi-File Plan Best Practices** (line 931) - Add dependency guidelines

All updates are backward compatible - existing documentation remains valid.

---

## References to New Documentation

Add these reference sections in appropriate places:

```markdown
**For complete cross-file dependency documentation:**
- See [Cross-File Dependencies Reference](./docs/CROSS_FILE_DEPENDENCIES.md) for syntax, examples, and patterns
- See [Migration Guide](./docs/MIGRATION_CROSS_FILE_DEPS.md) for migrating existing plans
```

---

## Summary of Changes

| Area | Change | Type |
|------|--------|------|
| Project Status | Updated to v2.5.0 | Update |
| High-Level Flow | Added cross-file resolution flow | Addition |
| Dependency Algorithm | Explained cross-file reference resolution | Enhancement |
| Task Metadata | Documented cross-file dependency syntax | Addition |
| Multi-File Examples | Added explicit cross-file dependency examples | Addition |
| Best Practices | Added cross-file guidelines | Addition |
| References | Added links to new documentation | Addition |

All changes are **backward compatible** with existing documentation.
