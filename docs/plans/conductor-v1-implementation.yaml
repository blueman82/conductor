plan:
  metadata:
    feature_name: "Conductor V1 - Multi-Agent Orchestration System"
    created: "2025-11-07"
    target: "Build autonomous multi-agent orchestration system in Go for executing implementation plans with Claude Code agents"
    estimated_tasks: 25
  context:
    framework: "Go 1.21+"
    architecture: "Standard Go project layout with cobra CLI framework"
    test_framework: "Go built-in testing package"
    other_context:
      - "Uses goroutines for concurrency"
      - "Follows cobra CLI framework patterns (like kubectl, docker CLI)"
      - "Parses both Markdown and YAML plan formats"
      - "Spawns Claude Code CLI subprocesses"
      - "Implements file locking for concurrent writes"
    expectations:
      - "Write tests BEFORE implementation (TDD - Red, Green, Refactor)"
      - "Commit frequently (after each completed task)"
      - "Follow Go idioms and conventions"
      - "Keep changes minimal (YAGNI - You Aren't Gonna Need It)"
      - "Avoid duplication (DRY - Don't Repeat Yourself)"
  prerequisites:
    - item: "Go 1.21 or later installed"
      details: "Run `go version` to verify"
      verified: false
    - item: "Claude Code CLI installed and in PATH"
      details: "Run `which claude` to verify"
      verified: false
    - item: "Git initialized in project directory"
      details: "Repository should have .git directory"
      verified: true
    - item: "Editor with Go support"
      details: "VS Code + Go extension recommended"
      verified: false
  tasks:
    # Phase 2A: Multi-File Plan Support & Objective Plan Splitting
    - task_number: 26
      name: "Add WorktreeGroup Support to Models"
      files:
        - "internal/models/task.go"
        - "internal/models/plan.go"
        - "internal/models/models_test.go"
      depends_on: []
      estimated_time: "30m"
      status: "completed"
      description: |
        Add WorktreeGroup field to Task struct and WorktreeGroups slice to Plan struct.
        Define WorktreeGroup type with metadata for group-based task organization.
      test_first:
        test_file: "internal/models/models_test.go"
        structure:
          - "TestTaskWorktreeGroup - verify WorktreeGroup field validation"
          - "TestPlanWorktreeGroups - verify WorktreeGroups slice handling"
        mocks: []
        fixtures: []
        assertions:
          - "Task should have WorktreeGroup field"
          - "Plan should have WorktreeGroups slice"
          - "WorktreeGroup metadata should be serializable"
        edge_cases:
          - "Empty WorktreeGroup"
          - "Invalid group references"
      implementation:
        approach: |
          Add WorktreeGroup string field to Task struct.
          Define WorktreeGroup type in plan.go with fields: GroupID, Description, ExecutionModel, Isolation, Rationale.
          Add WorktreeGroups []WorktreeGroup to Plan struct.
        code_structure: |
          type Task struct {
              Number        int
              Name          string
              WorktreeGroup string  // NEW
              // ... existing fields
          }

          type WorktreeGroup struct {
              GroupID       string
              Description   string
              ExecutionModel string
              Isolation     string
              Rationale     string
          }

          type Plan struct {
              Tasks           []Task
              WorktreeGroups  []WorktreeGroup  // NEW
              // ... existing fields
          }
        key_points:
          - point: "WorktreeGroup is string field on Task"
            details: "References group ID from Plan.WorktreeGroups"
          - point: "New WorktreeGroup type"
            details: "Contains metadata for group definition"
        integration:
          imports: []
          services_to_inject: []
          config_values: []
          error_handling:
            - "Validate WorktreeGroup references exist"
      verification:
        manual_testing:
          - step: "Create task with WorktreeGroup"
            expected: "Task accepts group assignment"
          - step: "Create plan with WorktreeGroups"
            expected: "Plan accepts groups slice"
        automated_tests:
          command: "go test ./internal/models/ -v"
        success_criteria:
          - "Task has WorktreeGroup field"
          - "Plan has WorktreeGroups field"
          - "Tests pass"
      commit:
        type: "feat"
        message: "add worktree group support to models"
        files:
          - "internal/models/task.go"
          - "internal/models/plan.go"
          - "internal/models/models_test.go"
      completed_date: "2025-11-11"
    - task_number: 27
      name: "Implement Multi-File Plan Loading"
      files:
        - "internal/parser/parser.go"
        - "internal/parser/markdown.go"
        - "internal/parser/yaml.go"
        - "internal/parser/parser_test.go"
      depends_on: [26]
      estimated_time: "1h 30m"
      status: "completed"
      description: |
        Enhance parser to detect directory input for split plans, implement ParseDirectory function
        to load all numbered files, auto-detect numbering pattern, and merge multiple parsed plans.
      test_first:
        test_file: "internal/parser/parser_test.go"
        structure:
          - "TestParseDirectory - load all files from directory"
          - "TestMergePlans - merge multiple parsed plans"
          - "TestDetectSplitPlan - identify split plan structure"
        mocks: []
        fixtures:
          - "testdata/split-plan-1.md"
          - "testdata/split-plan-2.md"
          - "testdata/split-plan-README.md"
        assertions:
          - "Should load all numbered files"
          - "Should merge plans correctly"
          - "Should maintain dependencies across files"
        edge_cases:
          - "Missing index file"
          - "Gaps in numbering"
          - "Invalid file format"
      implementation:
        approach: |
          Extend ParseFile() to detect directory vs file input.
          Add ParseDirectory() function to discover and load all numbered plan files.
          Implement MergePlans() to combine multiple parsed plans while preserving dependencies.
        code_structure: |
          func ParseFile(filename string) (*Plan, error)
          func ParseDirectory(dirname string) (*Plan, error)
          func MergePlans(plans ...*Plan) (*Plan, error)
        key_points:
          - point: "Auto-detect file vs directory"
            details: "Check if input is directory path"
          - point: "Auto-detect numbering pattern"
            details: "Look for 1-*.md, 2-*.yaml, etc."
          - point: "Merge preserves dependencies"
            details: "Cross-file task references work"
        integration:
          imports: []
          services_to_inject: []
          config_values: []
          error_handling:
            - "Handle missing numbered files"
            - "Validate merge consistency"
      verification:
        manual_testing:
          - step: "Parse split plan directory"
            expected: "All files loaded and merged"
        automated_tests:
          command: "go test ./internal/parser/ -v"
        success_criteria:
          - "ParseDirectory works"
          - "MergePlans works"
          - "Cross-file dependencies resolved"
          - "Tests pass"
      commit:
        type: "feat"
        message: "implement multi-file plan loading"
        files:
          - "internal/parser/parser.go"
          - "internal/parser/markdown.go"
          - "internal/parser/yaml.go"
      completed_date: "2025-11-11"
    - task_number: 28
      name: "Enhance Plan Validation for Multi-File Plans"
      files:
        - "internal/cmd/validate.go"
        - "internal/cmd/validate_test.go"
      depends_on: [27]
      estimated_time: "1h 30m"
      status: "completed"
      description: |
        Enhance validate command to handle multi-file plans, validate worktree groups,
        validate cross-file dependencies, and validate split boundaries.
      test_first:
        test_file: "internal/cmd/validate_test.go"
        structure:
          - "TestValidateMultiFilePlan - validate split plans"
          - "TestValidateWorktreeGroups - check group assignments"
          - "TestValidateCrossFileDeps - verify cross-file dependencies"
        mocks: []
        fixtures:
          - "testdata/valid-split-plan/"
          - "testdata/invalid-groups.yaml"
          - "testdata/broken-deps.md"
        assertions:
          - "Should detect multi-file plans"
          - "Should validate all worktree groups"
          - "Should resolve cross-file dependencies"
        edge_cases:
          - "Orphaned tasks without group"
          - "Invalid group references"
          - "Broken cross-file dependencies"
      implementation:
        approach: |
          Extend validate command to detect directory vs file input.
          Add function to validate worktree groups exist and are assigned to all tasks.
          Add function to validate cross-file task references.
          Add function to validate split boundaries.
        code_structure: |
          func ValidateMultiFilePlan(dir string) error
          func ValidateWorktreeGroups(plan *Plan) error
          func ValidateCrossFileDeps(plan *Plan) error
          func ValidateSplitBoundaries(dir string) error
        key_points:
          - point: "Validate group assignments"
            details: "Every task must have valid WorktreeGroup"
          - point: "Validate cross-file refs"
            details: "All task dependencies must exist"
        integration:
          imports: []
          services_to_inject: []
          config_values: []
          error_handling:
            - "Report detailed validation errors"
      verification:
        manual_testing:
          - step: "Validate valid split plan"
            expected: "Passes validation"
          - step: "Validate invalid split plan"
            expected: "Reports specific errors"
        automated_tests:
          command: "go test ./internal/cmd/ -v"
        success_criteria:
          - "Multi-file validation works"
          - "Group validation works"
          - "Cross-file dependency validation works"
          - "Tests pass"
      commit:
        type: "feat"
        message: "enhance plan validation for multi-file plans"
        files:
          - "internal/cmd/validate.go"
          - "internal/cmd/validate_test.go"
      completed_date: "2025-11-11"
    - task_number: 29
      name: "Annotate Dependency Graph with Worktree Groups"
      files:
        - "internal/executor/graph.go"
        - "internal/executor/graph_test.go"
      depends_on: [26]
      estimated_time: "45m"
      status: "completed"
      description: |
        Tag dependency graph nodes with worktree group information during BuildDependencyGraph,
        enhance Wave struct to track group metadata, update CalculateWaves to include group info.
      test_first:
        test_file: "internal/executor/graph_test.go"
        structure:
          - "TestGraphNodeGroups - verify group tagging"
          - "TestWaveGroupMetadata - verify wave includes group info"
        mocks: []
        fixtures: []
        assertions:
          - "Graph nodes should have group info"
          - "Waves should track group metadata"
        edge_cases:
          - "Mixed groups in wave"
          - "Group isolation violations"
      implementation:
        approach: |
          Enhance DependencyGraph struct to include Groups map[int]string (task number to group ID).
          Tag nodes with group during BuildDependencyGraph.
          Enhance Wave struct to include GroupInfo field.
          Update CalculateWaves to populate group metadata.
        code_structure: |
          type DependencyGraph struct {
              // ... existing fields
              Groups map[int]string  // NEW: task number -> group ID
          }

          type Wave struct {
              // ... existing fields
              GroupInfo map[string][]int  // NEW: group ID -> task numbers
          }
        key_points:
          - point: "Tag nodes during graph build"
            details: "Store group ID for each node"
          - point: "Wave includes group metadata"
            details: "Track which groups are active in wave"
        integration:
          imports: []
          services_to_inject: []
          config_values: []
      verification:
        manual_testing:
          - step: "Build graph with groups"
            expected: "Nodes tagged with group info"
        automated_tests:
          command: "go test ./internal/executor/graph_test.go -v"
        success_criteria:
          - "Graph tagging works"
          - "Wave metadata correct"
          - "Tests pass"
      commit:
        type: "feat"
        message: "annotate dependency graph with worktree groups"
        files:
          - "internal/executor/graph.go"
          - "internal/executor/graph_test.go"
      completed_date: "2025-11-11"
    - task_number: 30
      name: "Implement Multi-File Plan Merging in Orchestrator"
      files:
        - "internal/executor/orchestrator.go"
        - "internal/executor/orchestrator_test.go"
      depends_on: [27, 29]
      estimated_time: "1h"
      status: "completed"
      description: |
        Before building dependency graph, merge all loaded plan files, validate merged plan
        consistency, track file-to-task mapping for later updates.
      test_first:
        test_file: "internal/executor/orchestrator_test.go"
        structure:
          - "TestMergeMultiFilePlans - merge during orchestration"
          - "TestFileToTaskMapping - track file ownership"
        mocks: []
        fixtures: []
        assertions:
          - "Should merge files correctly"
          - "Should maintain file-to-task mapping"
          - "Should preserve all dependencies"
        edge_cases:
          - "Conflicting task numbers"
          - "Circular deps after merge"
      implementation:
        approach: |
          Add MergePlans function call in Run method before BuildDependencyGraph.
          Add FileToTaskMapping map to Orchestrator.
          Validate merged plan before execution.
        code_structure: |
          type Orchestrator struct {
              // ... existing fields
              FileToTaskMapping map[int]string  // NEW: task number -> file path
          }

          func (o *Orchestrator) Run(ctx context.Context, plans ...*Plan) error {
              merged := MergePlans(plans...)
              o.FileToTaskMapping = merged.GetFileMapping()
              // ... rest of execution
          }
        key_points:
          - point: "Merge before graph building"
            details: "Combines all task lists"
          - point: "Track file ownership"
            details: "Know which file each task came from"
        integration:
          imports: []
          services_to_inject: []
          config_values: []
      verification:
        manual_testing:
          - step: "Run with split plans"
            expected: "Plans merged correctly"
        automated_tests:
          command: "go test ./internal/executor/ -v"
        success_criteria:
          - "Multi-file merging works"
          - "File mapping maintained"
          - "Tests pass"
      commit:
        type: "feat"
        message: "implement multi-file plan merging in orchestrator"
        files:
          - "internal/executor/orchestrator.go"
          - "internal/executor/orchestrator_test.go"
      completed_date: "2025-11-11"
    - task_number: 31
      name: "Add File Tracking to Task Executor"
      files:
        - "internal/executor/task.go"
        - "internal/executor/task_test.go"
        - "internal/filelock/filelock.go"
        - "internal/filelock/filelock_test.go"
      depends_on: [30]
      estimated_time: "1h"
      status: "completed"
      description: |
        Track which file each task belongs to, update correct plan file when task completes,
        implement per-file locking strategy for safe concurrent updates.
      test_first:
        test_file: "internal/executor/task_test.go"
        structure:
          - "TestTaskFileTracking - verify file ownership"
          - "TestPerFileLocking - verify per-file locks work"
          - "TestUpdateCorrectFile - update right file on completion"
        mocks: []
        fixtures: []
        assertions:
          - "Task should know its source file"
          - "Updates should go to correct file"
          - "Locks should prevent conflicts"
        edge_cases:
          - "Multiple tasks in same file"
          - "Concurrent updates to same file"
          - "File deletion during update"
      implementation:
        approach: |
          Add SourceFile field to task context during execution.
          Modify task executor to use FileToTaskMapping to find source file.
          Implement per-file locking in filelock package.
          Update plan file only when task completes.
        code_structure: |
          func (te *TaskExecutor) Execute(ctx context.Context, task *Task) error {
              sourceFile := te.fileMapping[task.Number]
              lock := te.lockManager.Lock(sourceFile)
              defer lock.Unlock()
              // ... execute task
              // ... update only sourceFile
          }
        key_points:
          - point: "Track source file"
            details: "Know where task came from"
          - point: "Per-file locking"
            details: "Lock only files being written"
        integration:
          imports: []
          services_to_inject: []
          config_values: []
      verification:
        manual_testing:
          - step: "Execute task from split plan"
            expected: "Correct file updated"
        automated_tests:
          command: "go test ./internal/executor/ -v"
        success_criteria:
          - "File tracking works"
          - "Updates to correct file"
          - "Locking prevents conflicts"
          - "Tests pass"
      commit:
        type: "feat"
        message: "add file tracking to task executor"
        files:
          - "internal/executor/task.go"
          - "internal/executor/task_test.go"
          - "internal/filelock/filelock.go"
      completed_date: "2025-11-11"
    - task_number: 32
      name: "Comprehensive Testing for Phase 2A"
      files:
        - "internal/cmd/testdata/split-plan-*.md"
        - "internal/parser/testdata/split-plan-*.yaml"
        - "Various test files"
      depends_on: [26, 27, 28, 29, 30, 31]
      estimated_time: "1h 30m"
      status: "in-progress"
      description: |
        Create test fixtures for split plans, write comprehensive tests for multi-file
        merging, cross-file dependencies, worktree group validation, and integration scenarios.
      test_first:
        test_file: "Various test files"
        structure:
          - "TestData fixtures for split plans"
          - "Integration tests for Phase 2A features"
        mocks: []
        fixtures:
          - "testdata/split-plan-1.md"
          - "testdata/split-plan-2.md"
          - "testdata/split-plan-README.md"
          - "testdata/split-plan-1.yaml"
          - "testdata/split-plan-2.yaml"
        assertions:
          - "All Phase 2A features work together"
          - "Edge cases handled correctly"
          - "No regressions in V1 functionality"
        edge_cases:
          - "Empty split files"
          - "Large number of splits"
          - "Complex cross-file dependencies"
      implementation:
        approach: |
          Create realistic split plan test fixtures with multiple groups.
          Write integration tests covering full Phase 2A workflows.
          Verify backward compatibility with single-file plans.
          Add stress tests for large split plans.
        code_structure: |
          // Test fixtures in testdata/
          docs/plans/test-split/
          ├── 1-chain-1.md
          ├── 2-chain-2.md
          ├── 3-independent.md
          └── README.md
        key_points:
          - point: "Realistic test fixtures"
            details: "Multi-file plans with real scenarios"
          - point: "Integration testing"
            details: "Test full workflows"
          - point: "Backward compatibility"
            details: "Ensure V1 plans still work"
        integration:
          imports: []
          services_to_inject: []
          config_values: []
      verification:
        manual_testing:
          - step: "Run all Phase 2A tests"
            expected: "100% pass rate"
          - step: "Run V1 tests"
            expected: "No regressions"
        automated_tests:
          command: "go test ./... -v"
        success_criteria:
          - "Phase 2A tests pass"
          - "V1 tests pass"
          - "Coverage maintained or improved"
          - "All edge cases covered"
      commit:
        type: "test"
        message: "add comprehensive testing for phase 2a"
        files:
          - "internal/cmd/testdata/split-*.md"
          - "internal/parser/testdata/split-*.yaml"
    - task_number: 33
      name: "Update Documentation for Phase 2A"
      files:
        - "CLAUDE.md"
        - "README.md"
        - "docs/plans/phase-2a-guide.md"
      depends_on: [32]
      estimated_time: "45m"
      status: "pending"
      description: |
        Document Phase 2A features, add examples of split plans, explain worktree group
        assignments, update architecture diagrams to show multi-file support.
      test_first:
        test_file: "N/A"
        structure: []
        mocks: []
        fixtures: []
        assertions:
          - "Documentation is clear and complete"
          - "Examples are correct and runnable"
        edge_cases: []
      implementation:
        approach: |
          Update CLAUDE.md with Phase 2A overview.
          Add Phase 2A section to architecture documentation.
          Create examples of split plans in README.
          Document worktree group best practices.
        code_structure: |
          docs/plans/
          ├── phase-2a-guide.md      # Phase 2A walkthrough
          ├── examples/
          │   ├── split-plan-example/
          │   │   ├── 1-setup.md
          │   │   ├── 2-implementation.md
          │   │   └── README.md
          │   └── worktree-groups-example.yaml
        key_points:
          - point: "Clear Phase 2A documentation"
            details: "Explain feature, benefits, usage"
          - point: "Real-world examples"
            details: "Show split plan patterns"
          - point: "Best practices guide"
            details: "How to structure split plans"
        integration:
          imports: []
          services_to_inject: []
          config_values: []
      verification:
        manual_testing:
          - step: "Follow examples from docs"
            expected: "Examples work as documented"
          - step: "Read documentation"
            expected: "Clear and understandable"
        automated_tests:
          command: "N/A"
        success_criteria:
          - "Phase 2A documented"
          - "Examples provided"
          - "Best practices explained"
          - "Architecture updated"
      commit:
        type: "docs"
        message: "add documentation for phase 2a features"
        files:
          - "CLAUDE.md"
          - "README.md"
          - "docs/plans/phase-2a-guide.md"
  testing_strategy:
    unit_tests:
      location: "*_test.go files alongside implementation"
      naming_convention: "TestFunctionName for functions, TestTypeName_MethodName for methods"
      run_command: "go test ./..."
      coverage_target: "70%"
      coverage_command: "go test -cover ./..."
    integration_tests:
      location: "test/integration/"
      what_to_test:
        - "Full orchestration flows with sample plans"
        - "End-to-end plan parsing and execution"
        - "Multi-wave task execution"
      setup_required:
        - "Sample plan files"
        - "Mock agent responses"
        - "Test fixtures"
      run_command: "go test ./test/integration/..."
    e2e_tests:
      enabled: false
      location: "N/A"
      critical_flows: []
      tools: "N/A"
      run_command: "N/A"
    test_design_principles:
      patterns_to_use:
        - pattern: "Table-driven tests"
          example: |
            tests := []struct {
                name    string
                input   Task
                wantErr bool
            }{
                {"valid task", Task{...}, false},
                {"invalid task", Task{}, true},
            }
            for _, tt := range tests {
                t.Run(tt.name, func(t *testing.T) {
                    err := tt.input.Validate()
                    if (err != nil) != tt.wantErr {
                        t.Errorf("got error = %v, wantErr %v", err, tt.wantErr)
                    }
                })
            }
        - pattern: "Subtests with t.Run()"
          example: |
            func TestFeature(t *testing.T) {
                t.Run("scenario 1", func(t *testing.T) { ... })
                t.Run("scenario 2", func(t *testing.T) { ... })
            }
        - pattern: "Test fixtures in testdata/"
          example: |
            testdata/
            ├── sample-plan.md
            ├── sample-plan.yaml
            └── invalid-plan.md
      anti_patterns_to_avoid:
        - pattern: "Testing implementation details"
          why: "Makes tests brittle and coupled to implementation"
          instead: "Test behavior and outcomes, not internals"
        - pattern: "Tests with external dependencies"
          why: "Makes tests slow and unreliable"
          instead: "Use mocks and test doubles"
        - pattern: "Brittle tests that break on refactoring"
          why: "Creates maintenance burden"
          instead: "Test public interfaces, not private functions"
      mocking_guidelines:
        mock_these:
          - "External claude CLI (use test scripts)"
          - "File system operations (when appropriate)"
          - "Network calls"
        dont_mock_these:
          - "Internal functions"
          - "Simple utilities"
          - "Data structures"
        project_mocking_pattern:
          reference: "Use interfaces for testability"
          example: |
            // Define interface
            type Parser interface {
                Parse(r io.Reader) (*Plan, error)
            }

            // Mock implementation for tests
            type MockParser struct {
                ParseFunc func(r io.Reader) (*Plan, error)
            }
  commit_strategy:
    total_commits: 25
    commits:
      - sequence: 1
        type: "feat"
        description: "initialize Go module and project structure"
        files:
          - "go.mod"
          - "cmd/conductor/main.go"
          - "README.md"
          - ".gitignore"
        why_separate: "Foundation must be established first"
      - sequence: 2
        type: "feat"
        description: "add cobra CLI framework"
        files:
          - "go.mod"
          - "go.sum"
          - "internal/cmd/root.go"
          - "internal/cmd/root_test.go"
          - "cmd/conductor/main.go"
        why_separate: "CLI framework is independent infrastructure"
      - sequence: 3
        type: "feat"
        description: "define core data models"
        files:
          - "internal/models/task.go"
          - "internal/models/plan.go"
          - "internal/models/result.go"
          - "internal/models/models_test.go"
        why_separate: "Core domain models are foundation for other features"
      - sequence: 4
        type: "feat"
        description: "implement markdown plan parser"
        files:
          - "internal/parser/markdown.go"
          - "internal/parser/markdown_test.go"
          - "internal/parser/testdata/sample-plan.md"
          - "go.mod"
          - "go.sum"
        why_separate: "Parser is substantial feature, deserves own commit"
      - sequence: 5
        type: "feat"
        description: "implement YAML plan parser"
        files:
          - "internal/parser/yaml.go"
          - "internal/parser/yaml_test.go"
          - "internal/parser/testdata/sample-plan.yaml"
        why_separate: "Alternative parser format, separate concern"
    message_format:
      pattern: "type: brief description in present tense"
      examples:
        - "feat: add user authentication with JWT"
        - "fix: resolve race condition in async handler"
        - "test: add edge case coverage for validation"
        - "refactor: extract common logic to utility"
      example_from_history: |
        feat: implement markdown plan parser
    commit_guidelines:
      - "Keep commits atomic - one logical change per commit"
      - "Write clear, descriptive messages in imperative mood"
      - "Commit after each completed task"
      - "Tests and implementation in same commit (after TDD red-green)"
  common_pitfalls:
    - pitfall: "Goroutine leaks"
      why: "Forgetting to close channels or wait for goroutines"
      how_to_avoid: "Use sync.WaitGroup, defer close(), context cancellation"
      reference:
        file: "Standard Go concurrency patterns"
        pattern: "Always clean up goroutines"
    - pitfall: "Race conditions in plan updates"
      why: "Multiple goroutines writing to plan file"
      how_to_avoid: "Use flock file locking"
      reference:
        file: "github.com/gofrs/flock examples"
        pattern: "Lock before write, unlock after"
    - pitfall: "Timeout not propagating"
      why: "Not passing context through call chain"
      how_to_avoid: "Always pass context.Context as first parameter"
      reference:
        file: "Go context package documentation"
        pattern: "Context should be first parameter"
    - pitfall: "Circular dependencies not detected"
      why: "Incorrect graph traversal"
      how_to_avoid: "Implement proper DFS with color marking"
      reference:
        file: "Task 7 graph implementation"
        pattern: "Use white-gray-black coloring for cycle detection"
  resources:
    existing_code:
      - type: "Completed tasks"
        path: "internal/models/"
        note: "Study the models package structure"
      - type: "Test examples"
        path: "internal/parser/markdown_test.go"
        note: "Follow testing patterns used here"
      - type: "Go idioms"
        path: "All existing .go files"
        note: "Maintain consistent code style"
    documentation:
      - type: "Go Project Layout"
        link: "https://github.com/golang-standards/project-layout"
        relevance: "Standard project structure"
      - type: "Cobra CLI"
        link: "https://github.com/spf13/cobra"
        relevance: "CLI framework documentation"
      - type: "Effective Go"
        link: "https://go.dev/doc/effective_go"
        relevance: "Go best practices"
    external_resources:
      - title: "Goldmark documentation"
        url: "https://github.com/yuin/goldmark"
        why: "Markdown parsing library"
      - title: "YAML v3 for Go"
        url: "https://github.com/go-yaml/yaml"
        why: "YAML parsing library"
      - title: "File locking in Go"
        url: "https://github.com/gofrs/flock"
        why: "Concurrent file access"
    validation_checklist:
      - item: "All tests pass"
        command: "go test ./..."
        checked: false
      - item: "Code formatted correctly"
        command: "gofmt -w ."
        checked: false
      - item: "Linter passes"
        command: "golangci-lint run"
        checked: false
      - item: "No race conditions"
        command: "go test -race ./..."
        checked: false
      - item: "Build succeeds"
        command: "go build ./cmd/conductor"
        checked: false
      - item: "Binary works"
        command: "./conductor --help"
        checked: false
      - item: "Documentation updated"
        files: "README.md, relevant docs"
        checked: false
  progress_summary:
    last_updated: "2025-11-10"
    total_tasks: 25
    completed_tasks: 20
    completion_percentage: 80
    phases:
      - name: "Phase 1 (Foundation)"
        status: "COMPLETE"
        progress: "100%"
      - name: "Phase 2 (Core Execution)"
        status: "COMPLETE"
        progress: "100%"
      - name: "Phase 3 (Concurrency & Orchestration)"
        status: "COMPLETE"
        progress: "100%"
      - name: "Phase 4 (CLI Interface)"
        status: "COMPLETE"
        progress: "100%"
      - name: "Phase 5 (Advanced Features)"
        status: "IN PROGRESS"
        progress: "20%"
      - name: "Phase 6 (Robustness)"
        status: "PENDING"
        progress: "0%"
    latest_milestone:
      task_number: 20
      task_name: "Configuration File Support"
      completed_date: "2025-11-10"
      status: "COMPLETE"
      qa_verdict: "GREEN"
      test_coverage: "100%"
      test_count: 18
      lines_of_code: 706
    quality_metrics:
      overall_test_coverage: "78.3%"
      total_tests: 451
      tests_passing: 451
      tests_failing: 0
      race_conditions: 0
      build_status: "SUCCESS"
      production_ready: true
